## 기능 구현 목록

- [x] 문제1
  
  양 페이지마다 숫자를 더하고 곱하는 연산을 하여 최댓값을 구한다.
  포비와 크롱 둘 다 위 과정을 거치고 둘을 비교한다.
  예외상황으로는 주어지는 쪽수의 숫자가 잘못된 경우로 생각했다.
  </br>
  </br>
- [x] 문제2
  </br>
  </br>
  스택과 큐를 이용하여 해결하였다.
  문자열을 큐로 옮겨담은 후, 큐에서 하나씩 꺼내어 스택에 담는다.
  이때, 스택의 맨 위의 값과 큐의 맨 아래 값이 동일하다면 둘 다 삭제해준다.
  그렇지 않다면 큐에서 맨 밑값을 빼내어 스택에 넣어준다.
  큐가 비어질 때 까지 반복한다.
  </br>
  </br>
- [x] 문제3
  </br>
  </br>
  주어진 숫자까지 반복문을 돈다.
  숫자를 문자열로 바꾼 다음, 하나씩 쪼개어 3,6,9와 동일한 숫자가 있는지 확인한 후, answer에 반영한다.
  </br>
  </br>
- [x] 문제4
  </br>
  </br>
  해시맵에 각각의 알파벳과 대치되는 새로운 알파벳을 키-밸류로 넣어주었다.
  그리고 주어진 문자열을 해시맵에 있는 값으로 대치시켜주었다.
  이때, 대소문자에 예외사항을 두고 코드를 작성하였다.
  </br>
  </br>
- [x] 문제5
  </br>
  </br>
  가장 큰 금액부터 할당하였다.
  이어서 숫자가 0이 될 때 까지 금액을 계산하였다.
  예를들어 51200원은 50000원권 한장만 할당 가능하다.
  이후 남은 1200원에서 1000원 한장, 100원 2개 이런식으로 할당하였다.
  </br>
  </br>
- [x] 문제6
  </br>
  </br>
  이름을 두글자씩 떼어낸 후, 해시에 담았다. 예를들어 '제이엠'이란 이름은
  '제이','이엠'으로 분해 가능한데, 해시맵에는 {제이:{1}}, {이엠:{1}}이런 식으로 담았다.
  이후 2번 문자열에서 '제이'라는 문자열이 등장했다면 해시맵에 {제이:{1,2}}로 갱신해주고, 1,2번 문자열이 중복되었음을 기재했다.
  이때, 만약 '제이이이엠'이라는 이름이 등장하게 된다면 {제이:{1}},{이이:{1,1}}, {이엠:{1}} 이렇게 중복될 경우가 있을것으로 판단되었다.
  이런 중복을 피하기 위해 먼저 리스트에 담은 후, 해시에 담았다.
  </br>
  </br>
- [x] 문제7
  </br>
  </br>
  주어진 배열 friends에서 먼저 사용자의 친구를 찾고, 사용자의 친구의 친구를 찾았다.
  이후 visitors에서 사용자의 친구를 제외한 사람들을 선별하여 점수를 부여하였다.
  이후 정렬을 하였는데, 점수 순으로 내림차순을 하고, 점수가 같으면 이름 순으로 오름차순이 되도록 정렬하였다.
  이를 위해 stream을 이용하였다.