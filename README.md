# 우아한테크코스 - 1주차 과제 

## ✏️ 기능 구현 문서 
- 1️⃣: [문제 1](https://github.com/Cl8D/java-onboarding/blob/cl8d/src/main/java/onboarding/docs/Problem1.md)
- 2️⃣: [문제 2](https://github.com/Cl8D/java-onboarding/blob/cl8d/src/main/java/onboarding/docs/Problem2.md)
- 3️⃣: [문제 3](https://github.com/Cl8D/java-onboarding/blob/cl8d/src/main/java/onboarding/docs/Problem3.md)
- 4️⃣: [문제 4](https://github.com/Cl8D/java-onboarding/blob/cl8d/src/main/java/onboarding/docs/Problem4.md)
- 5️⃣: [문제 5](https://github.com/Cl8D/java-onboarding/blob/cl8d/src/main/java/onboarding/docs/Problem5.md)
- 6️⃣: [문제 6](https://github.com/Cl8D/java-onboarding/blob/cl8d/src/main/java/onboarding/docs/Problem6.md)
- 7️⃣: [문제 7](https://github.com/Cl8D/java-onboarding/blob/cl8d/src/main/java/onboarding/docs/Problem7.md)

---

## 🔍 소감 
- 첫 우아한 테크코스 과제인 만큼 며칠 동안 여러 가지 고민을 했었던 것 같습니다.

### 🧐 **커밋 메시지 남기기**
- 여러 개의 문제 번호로 나뉘어진 상황에서, 일괄적으로 feat, fix를 사용하기에는 가독성이 떨어질 것이라고 생각했습니다. 
  - 여러 커밋 컨벤션을 찾아보다가, angularJs의 커밋 메시지 규약 정리본을 확인하고 커밋 시 scope를 정할 수 있다는 걸 확인하였습니다. 
  이후 스코프에 문제 번호를 넣어 커밋을 진행하였으며, 이 덕분에 어떤 문제에 대해 변경이 일어났는지 쉽게 파악할 수 있었습니다.
- 또한, 일괄적인 커밋 메시지 규칙을 세우기 위해 모든 문자는 소문자로, 첫 단어는 명령형으로, 끝에는 마침표를 붙이지 않도록 노력하였습니다.
  - 초기 커밋 시에는 이런 규칙을 잘 모르는 상태로 커밋해서 들쑥날쑥한 게 있지만, 뒤로 갈수록 이런 부분에 대해 지키려고 노력했습니다. 특히, 초반의 feat의 경우 무조건 ‘add + (기능 설명)’ 형태로 작성하였으나, feat 자체가 ‘새로운 feature의 추가’를 담고 있다고 판단하여 이후에는 add를 제거하고 바로 명령형으로 해당 기능에 대해 작성하였습니다.

### 😎 **기능 단위 커밋하기** 
- ‘기능 단위의 커밋’을 지키려고 노력했습니다. 
  - 새로운 기능을 만들면 해당 문제 번호와 기능에 대해 커밋을 진행하였습니다. 
  다만, 이 과정에서 오탈자나 작은 리팩토링 과정도 담다 보니 커밋 횟수가 너무 늘어난 건 아닐까 걱정하였습니다. 
  그래서 후반부에는 일괄 리팩토링이나 문서 수정에 대해서는 하나의 큰 기능으로 보고 한 번에 커밋을 진행하였습니다. 
  어떤 방식이 옳고 틀린지는 아직 판단이 확실하게 안 서지만, 메서드 단위 커밋은 가독성에 좋다고 생각되어 앞으로도 계속 가져가고자 합니다.

### 😅 **기능 명세 작성하기**
- 기능 명세를 작성하는 것은 꽤나 힘든 작업이었습니다.
  - 평소 코딩을 할 때 주석을 통해 1차적으로 코드를 작성해나가며 진행하는 스타일이라 사전에 모든 기능을 정의해두고 코드를 짜는 건 쉽지 않았습니다. 
  특히, 코드에 변경사항이 발생했을 때 다시 문서를 수정해야 하는 점이 번거롭게 느껴지기도 했습니다. 
  그러나, 저만을 위한 코드가 아닌 다른 사람을 위한 코드, 특히 협업 시에는 기능 목록을 미리 선언해둬야 저의 코드를 타인이 쉽게 이해할 수 있을 것 같다는 생각이 들었습니다. 
  저 역시 프로그램을 점검할 때 구현 로직을 따라 코드를 보니 더 쉽게 읽히는 것을 느꼈으며, 추후 과제 진행 시에도 기능 및 로직 설명은 별도의 문서로 관리할 예정입니다.

### 😌 **indent 줄이기**
- 메서드 생성 시 최대한 indent를 1 이하로 하도록 노력하였습니다. 
  - indent를 작게 가져가기 위해서는 메서드를 작게 분리하는 게 중요했습니다. 
  기존에 별도의 메서드 분리 없이 하나의 메서드 안에서 쭉 작성하던 코딩 방식에서 벗어나기 위해, 기획 부분에서 더 신경을 기울였던 시간이었던 것 같습니다.
- 또한, if-else로 나뉠 수 있는 부분은 모두 if문의 조건에서 return을 주어 else 예약어를 쓰지 않도록 노력하였습니다.
  - 번외로, if문 내의 조건을 줄 때 항상 부정 조건에 대해서 검사하면(!를 사용하여 조건) ‘boolean method is always inverted’ 경고가 뜨는 걸 확인했습니다. 이를 처리하기 위해 메서드명을 isNot으로 바꿔서 명시적으로 조건이 부정일 때 true 값을 리턴하도록 하여, if문 내에서는 긍정 조건으로서 처리할 수 있도록 변경하였습니다.

### 🤭 **네이밍과 예외사항 처리하기**
- 변수명, 메서드명은 가장 기본적이지만 고민을 많이 한 부분이었습니다. 
  - 기존에 코딩할 때는 변수명이 너무 길어질수록 가독성이 떨어진다는 생각에 간결하게 가져갔었지만, 
  1차 과제를 진행하면서 너무 짧은 변수명은 오히려 의미 전달에 용이하지 못하다는 걸 깨달았습니다. 
  네이밍 시 최대한 각 기능을 표현할 수 있도록 신경써서 작업하였습니다.
- 제한사항을 벗어나는 입력이 들어왔을 때 어떻게 처리할지 고민했습니다. 
  - 1번 문제의 경우 명시적으로 -1을 리턴하도록 하였으나, 다른 문제는 예외 사항에 대한 별도의 처리 방식이 없었기 때문에 어떻게 처리할지 고민하였습니다.
  초기에는 각각의 세부사항에 따라서 예외를 두었으나, 그렇게 하면 예외 클래스가 너무 많아지는 것 같다는 생각이 들었습니다. 
  - 그래서 가장 공통적으로 쓰이는 입력에 대한 범위 예외와, 입력에 대한 타입 예외로 나누었습니다. 
  범위 예외(InputRangeException)는 입력 숫자의 범위가 벗어났을 때, 타입 예외(InputTypeException)는 소문자나 한글이 들어와야 하는데 다른 문자가 들어온 경우를 처리하였습니다. 
  덕분에 2가지의 예외 사항으로 모든 케이스를 커버할 수 있어 코드가 조금 더 클린해졌다고 생각됩니다.

### 😵‍💫 **클래스 분리하기**
- 공통으로 쓰이는 클래스를 분리하였습니다.
    - 7문제가 주어지면서 클래스 분리를 할 수 있을지 고민하였습니다.
모든 문제에 대해 패키지별로 나누어서 처리하기에는, 간단한 문제인 만큼 오히려 가독성을 해칠 것 같다는 생각이 들었습니다.
이를 위해 각 문제마다 공통적으로 사용하는 메서드를 분리하였습니다. 
    - 입력 문자열에 대한 유틸 클래스인 InputStringUtil을 통해 문자열을 char[]로 분리하록 처리하였습니다. 
  공통된 제한사항은 ValidationUtil 클래스를 활용하여 시작, 끝 범위를 주면 그에 맞게 입력받은 문자에 대한 범위 체크를 하거나, 입력 문자열이 소문자로 구성되어 있는지 체크하였습니다. 
  또한, 예외 메시지 처리를 위해 해당 변수 이름을 클래스의 필드로 관리하여, 각 문제마다 공통으로 처리할 수 있는 부분은 객체 생성을 통해 용이하게 예외 메시지를 관리하였습니다.

### 🤗 **정규식 공부하기**
- 정규식에 대해 공부할 수 있던 시간이었습니다.
    - 제한사항 중 소문자로 이루어져있는지 검증할 때, 초기에는 Character.isAlphabetic()을 활용해 반복문으로 하나씩 체크하였습니다.
  그러나, 이 방식은 너무 낭비인 것 같아 조금 더 효율적인 코드를 고민하였고, 정규식을 활용하는 방법을 택하였습니다.
    - 정규식 덕분에 문제 2번에서 중복된 문자열을 제거할 때, 반복문으로 체크하지 않고 {n, }를 활용하여 쉽게 처리할 수 있었습니다. 
  또한, 소문자/한글 검증 시 Pattern.matches()를 활용하여 문자열이 해당 정규 표현식에 일치하는지 체크할 수 있어 코드를 짧게 가져갈 수 있었습니다.