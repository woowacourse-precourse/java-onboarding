# 미션 - 온보딩

## 🔍 진행 방식

- 미션은 **기능 요구 사항, 프로그래밍 요구 사항, 과제 진행 요구 사항** 세 가지로 구성되어 있다.
- 세 개의 요구 사항을 만족하기 위해 노력한다. 특히 기능을 구현하기 전에 기능 목록을 만들고, 기능 단위로 커밋 하는 방식으로 진행한다.
- 기능 요구 사항에 기재되지 않은 내용은 스스로 판단하여 구현한다.

## 📮 미션 제출 방법

- 미션 구현을 완료한 후 GitHub을 통해 제출해야 한다.
    - GitHub을 활용한 제출 방법은 [프리코스 과제 제출](https://github.com/woowacourse/woowacourse-docs/tree/master/precourse) 문서를 참고해
      제출한다.
- GitHub에 미션을 제출한 후 [우아한테크코스 지원](https://apply.techcourse.co.kr) 사이트에 접속하여 프리코스 과제를 제출한다.
    - 자세한 방법은 [제출 가이드](https://github.com/woowacourse/woowacourse-docs/tree/master/precourse#제출-가이드) 참고
    - **Pull Request만 보내고 지원 플랫폼에서 과제를 제출하지 않으면 최종 제출하지 않은 것으로 처리되니 주의한다.**

## 🚨 과제 제출 전 체크 리스트 - 0점 방지

- 기능 구현을 모두 정상적으로 했더라도 **요구 사항에 명시된 출력값 형식을 지키지 않을 경우 0점으로 처리**한다.
- 기능 구현을 완료한 뒤 아래 가이드에 따라 테스트를 실행했을 때 모든 테스트가 성공하는지 확인한다.
- **테스트가 실패할 경우 0점으로 처리**되므로, 반드시 확인 후 제출한다.

### 테스트 실행 가이드

- 터미널에서 `java -version`을 실행하여 Java 버전이 11인지 확인한다. 또는 Eclipse 또는 IntelliJ IDEA와 같은 IDE에서 Java 11로 실행되는지 확인한다.
- 터미널에서 Mac 또는 Linux 사용자의 경우 `./gradlew clean test` 명령을 실행하고,   
  Windows 사용자의 경우  `gradlew.bat clean test` 명령을 실행할 때 모든 테스트가 아래와 같이 통과하는지 확인한다.

```
BUILD SUCCESSFUL in 0s
```

---

## 🚀 기능 요구 사항
아래의 7가지 기능 요구 사항을 모두 해결해야 한다.

1. [문제 1](./docs/PROBLEM1.md)
2. [문제 2](./docs/PROBLEM2.md)
3. [문제 3](./docs/PROBLEM3.md)
4. [문제 4](./docs/PROBLEM4.md)
5. [문제 5](./docs/PROBLEM5.md)
6. [문제 6](./docs/PROBLEM6.md)
7. [문제 7](./docs/PROBLEM7.md)

---

## 🎯 프로그래밍 요구 사항

- JDK 11 버전에서 실행 가능해야 한다. **JDK 11에서 정상적으로 동작하지 않을 경우 0점 처리한다.**
- `build.gradle`을 변경할 수 없고, 외부 라이브러리를 사용하지 않는다.
- 프로그램 종료 시 `System.exit()`를 호출하지 않는다.
- 프로그램 구현이 완료되면 `ApplicationTest`의 모든 테스트가 성공해야 한다. **테스트가 실패할 경우 0점 처리한다.**
- 프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 이름을 수정하거나 이동하지 않는다.

---

## ✏️ 과제 진행 요구 사항

- 미션은 [java-onboarding](https://github.com/woowacourse-precourse/java-onboarding) 저장소를 Fork & Clone해 시작한다.
- 과제 진행 및 제출 방법은 [프리코스 과제 제출](https://github.com/woowacourse/woowacourse-docs/tree/master/precourse) 문서를 참고한다.

---

# 문제 해결 과정

## Problem1

### 기능 목록

- 입력값의 예외를 처리
- 페이지의 자릿수를 모두 더함
- 페이지의 자릿수를 모두 곱함
- 페이지의 최대값을 구함
- 두 페이지에서의 최대값을 구함
- 점수를 비교하여 승, 패를 알림

### 고려한 점

- 포비와 크롱이 펼친 페이지가 주어진다. 왼쪽 페이지는 홀수, 오른쪽 페이지는 짝수이며 **[왼쪽 페이지 번호, 오른쪽 페이지 번호]가 순서대로** 들어있다. 시작 면이나 마지막 면이 나오도록 책을 펼치지 않는다.
  - 실행 결과 예시를 보면, [99, 102]가 들어왔을 때 -1을 반환했다. 즉, **input 자체가 문제의 제한사항을 지키지 않는 경우**에 대해 예외사항 처리를 해야 한다.
  - 왼쪽, 오른쪽 페이지 번호가 순서대로 들어와야 하며, 시작 면이나 마지막 면이 나오지 않아야 한다는 것에 대해 많은 의견이 있었다. 내가 내린 결론은, 위에서 정의내린 것처럼 **input이 뭐가 들어오던지 예외처리를 해보자**고 생각했다.
  - 이하, 입력값의 예외를 생각해 본 목록이다. 펼친 페이지 타입은 `List<Integer>`이므로, 해당 범위 안에서 예상치 못 한 상황을 고려했다.
    - pobi와 crong의 길이가 2가 아닌 경우
    - [왼쪽 페이지 번호, 오른쪽 페이지 번호]가 [홀수, 짝수] 형태가 아닌 경우
    - [왼쪽 페이지 번호, 오른쪽 페이지 번호]가 연속되지 않은 경우
    - [왼쪽 페이지 번호, 오른쪽 페이지 번호] 중 null이 포함된 경우
    - 페이지 번호가 1 이하, 400 이상인 경우(시작 면과 마지막 면을 1과 400이라 가정)
- 왼쪽 페이지와 오른쪽 페이지 번호의 각 자리 숫자를 모두 더하거나, 모두 곱해 가장 큰 수를 구한다.
  - 페이지 번호의 각 자리 숫자들을 모두 더하고, 모두 곱한 값 중 최대값을 반환해야 한다.
  - 숫자들을 더하는 기능과 곱하는 기능으로 분리시킬 수 있다.
  - 추가적인 계산식이 생성되었을 경우, 함수 내 수식을 수정하는 게 아닌 추가하는 방향이라면 유지·보수에도 좋지 않을까 했다. 따라서 `수식`을 함수로 만들고, 해당 수식들을 거쳐가며 최대값을 유지하는 형태로 작성하기로 했다.
  - 현재 문제 내에서는 수식이 두 개 밖에 없으므로, 둘 중 큰 값을 반환하도록 설계.
- 왼쪽 페이지의 최대 도출값과 오른쪽 페이지의 최대 도출값 중 큰 값을 본인의 점수로 한다.
  - 왼쪽 페이지의 값과 오른쪽 페이지의 값 중 큰 값을 도출. 해당 시점에서는 양 페이지에서 도출된 값을 단순 비교하는 경우이니, 무언가 추가되거나 수정될 사항이 적다고 생각했다. 따라서 단순하게 큰 값을 반환하도록 설계.
- 점수를 비교하여 게임의 승자를 구하고, 포비가 이겼다면 1, 크롱이 이겼다면 2, 무승부는 0으로 한다.
  - 슬랙에서 포비의 승, 크롱의 승, 무승부에 대해 final로 지정하고 반환하는 방식이 코드 가독성에 좋을 것 같다는 의견이 있었다. 지금까지 코드를 구성하면서 생각하지 못 해봤던 것 같다. 해당하는 방식으로 직접 작성을 해 보기로 하였다.

### 고민한 사항

- 하나의 메서드는 하나의 기능을 담당해야 한다. `펼친 페이지들을 기반으로 내 점수를 계산하여 반환하는 메서드` -> `각각의 페이지에서 얻을 수 있는 최대 점수를 반환하는 메서드` -> `페이지 자릿수를 다 더한 값을 반환하는 메서드`와 `다 곱한 값을 반환하는 메서드 `로 나눠 작성했다.
- 헌데 이게 옳은 구조인지, 괜찮은 구조인지 감이 잘 오지 않았다. 기존 방식처럼 펼친 페이지의 좌, 우를 구분하고 각 값을 `페이지 자릿수를 다 더한 값을 반환하는 메서드`와 `다 곱한 값을 반환하는 메서드`에 넣어 바로 값을 반환하는 편이 낫지 않은지 생각했다.
- 그러나 이는 코드의 재사용성을 낮추고, 유지보수가 힘들어지는 길이라 했으므로 익숙함을 탈피해보도록 했다. 점수를 계산하는 수식이 추가된다면, `각각의 페이지에서 얻을 수 있는 최대 점수를 반환하는 메서드`에서 추가적인 함수 호출을 하면 되므로 추가적인 고민 사항을 덜 수 있을 것 같았다.
- 하지만 아직까지는 이 방식이 과연 옳은 것인지 단념할 수 없는 것 같다. 더 좋은 방법이 없을지 계속 생각하게 된다.

### 리팩터링

- 플레이어와 게임의 진행에 대해 생각하며, 둘의 클래스를 따로 생성하여 구조화해보기로 했다.
  - 페이지의 입력이 잘못 들어왔는지는 게임을 시작한 후 판단하는 게 아니다. 게임 시작 전, 잘못된 점이 없는지 확인하는 게 먼저일 것이다. 따라서 플레이어 객체가 스스로 고려해보고, 만약 오류가 있다면 게임의 결과를 `오류있음`으로 도출해야 할 것이다.
  - 플레이어는 이상이 없다면 본인의 두 페이지를 지정해둔다.
  - 게임은 하나의 룰일 뿐이다. 해당 룰을 선언하고, 플레이어 두 명을 받아들여 룰을 진행한다.
  - 룰에 맞게 게임이 진행되고, 최종 결과를 반환한다.
- 게임의 점수는 `룰`에 좌우되므로, 플레이어 객체가 들고있지 않게끔 한다.
  - 두 사람, 세 사람이 진행하면 룰이 바뀌는 게임이 있고, 해당하는 방법에서 얻을 수 있는 점수도 다르다. 만약 점수를 플레이어 객체가 들고 있게끔 한다면, 가장 높은 점수를 얻을 수 있는 룰을 찾아 본인의 점수를 갱신할 것이다. 따라서 현재 하나의 게임 룰만 따른다 해도, 점수를 직접적으로 플레이어 객체가 들고 있지 않게 만들어야 할 것이다.

## Problem2

### 기능 목록

- 현재 해독문의 마지막 문자와 같은 암호문 문자 건너뜀
- 건너뛴 문자가 있었는지 유무 확인
  - ~~해독문 문자 삭제~~
  - 해독문 문자 추가

- 반복수행하며 더 해독이 불가할 때까지 진행
- 해독문 반환

### 고려한 점

- 반복문을 돌면서 문자를 확인한다.
- 해당 문자가 연속된 문자라면 삭제한다.
  - 연속된 문자란, **같은 문자가 2번 이상 나올 때**이다. 예시에서는 2번이 최대로 나오지만, 더 많이 등장할 수 있기에 해당하는 사항을 살리려 노력했다.
  - ~~해독문의 마지막 문자와 같은 암호문 문자들이 들어온다면, 새로운 문자가 나올 때까지 idx를 증가시킨 후 기존의 마지막 문자를 삭제했다.~~
  - ~~해독문의 마지막 문자와 다른 문자가 등장했을 시에만 해독문을 추가시켰다.~~
  - 암호문의 현재 위치(head) 문자와 이후 위치(tail) 문자가 다를 때에만 추가, 만약 같다면 같은 문자들을 건너뛰었다.
- 해독 이전과 이후의 길이가 같다면 더 이상 해독이 진행되지 않는 상태이므로 반환해주도록 했다.

### 고민한 사항

- solution에서 while을 걸고 연속된 문자인지에 따라 if문 분기를 두려 했다. 그러나 하나의 메소드 당 하나의 들여쓰기만을 허용한다면 이는 해당 규칙을 어긴 셈이 되었다. 따라서 메소드를 나누고, 해당 메소드에게 문자 중복 등을 판단하도록 하였다. 잘못된 판단으로 기능 목록을 계속 갈아엎게 되어서 좀 아쉬웠다.
- 코드 작성 중 로직을 잘못 구현했었는데, 확실히 해당 메서드만 수정하고 호출하는 타이밍만 바꾸니 굉장히 매끄럽게 로직 변경이 가능했다. 이렇게나 쉽게 흐름이 바뀌는구나 생각했다. 그러나 기존의 `해독문의 마지막 글자를 삭제할지, 추가시킬지` 확인하는 메서드에서 idx의 상태를 반환하도록 코드가 변경되었다. 이 부분도 따로 메서드로 빼내야 하지 않을까 고민했으나, else 예약어를 사용하지 않으려면 빠른 return이 필요했기에 차라리 idx를 이용한 암호문 확인 메서드를 따로 작성하여 자연스러움을 추구했다. 그러나 이러한 방식이 정답이라고는 볼 수 없을 것 같다.어떤 식으로 코드를 작성하는 게 좋을 지 많은 고민이 필요할 것 같다.

### 리팩터링

- **문제 조건을 잘못 해석했다.** 한번씩 암호를 훑으며, 중복된 단어가 나올 시 없애는 방식인데 `aabaaabaabbabbaa`라면 답은 `a`가 나와야 한다.

- ```
  aabaaabaabbabbaa
  bba
  a
  ```

- 하지만 나는 한 번에 쌓이며 터지는 형식을 생각했기에 스택을 사용하였고, 이는 곧 오답을 도출했다. 따라서 스택을 없앴고, 암호문을 읽으며 중복된 문자를 없애고 `오직 하나의 문자`가 나올 때 새 문자열에 추가하여 반환하도록 했다.

- [클래스명으로 `er`을 붙이지 말자](https://jackjeong.tistory.com/147)라는 글을 보고 `Decrypter`라 작성한 클래스 명을 `Decrypt`로 변경하였다.

  - 헌데, Problem1 같이 실제 게임을 플레이하는 인원을 지정하는 데에는 er을 붙여도 되는지 잘 모르겠다. 우선 `Decrypt`는 해독해주는 사람이 아니라 단순 해독 클래스이기 때문에 er을 제거하였다.

- 암호를 해독해 주는 `Decrypt`를 선언하고, 원하는 암호문을 넣으며 `run` 메서드를 돌리면 해독문이 나오게끔 수정하였다.

## Problem3

### 기능 목록

- 주어진 number만큼 숫자를 올림
- 현재 숫자에서 한 자리씩 구분하여 넘김
- 넘어온 숫자가 3, 6, 9인지 확인하여 손뼉 횟수 증가

### 고려한 점

- 반복문을 돌며 해당 숫자의 자릿값을 구한다.
- 자릿값이 3, 6, 9라면 손뼉을 친다.
  - `Problem1`처럼 3, 6, 9에 대해 `static final`로 작성하였다. 만약 3, 6, 9 게임이 아니라 2, 4, 8 게임으로 변경된다면 해당 숫자 지정 부분만 변경하여 게임의 진행에 문제가 없도록 하였다.
  - 손뼉을 쳐야 할지, 치지 말아야 할 지도 `static final`로 작성하여 가독성있게끔 하였다.

### 고민한 사항

- 가장 쉬운 문제였던 것 같다. 로직 자체를 구성하는 것, 하나의 들여쓰기만 할 것에 주의하며 기능 목록을 작성하였고, 이번에는 수정 없이 빠르게 작성할 수 있었다.
- 다만, 아직도 `자릿값을 구해 전달하는 메서드`에서 `손뼉 횟수를 반환해도 되는지`를 잘 모르겠다. 메서드 명에 직접적으로 손뼉 횟수를 반환할 것이라 적어둔다 해도, 코드 내부 구성에서 하나의 기능만 책임지는 게 되는 것인지? 오히려 그렇게 되면 `자릿값을 구한다`, `손뼉 횟수를 반환한다`의 두가지를 책임진다는 게 명시적으로 나타내지는 것 같다..

### 리팩터링

- 박수치는 게임을 클래스로 선언. `369게임`을 기본 룰로 하며, 생성자 및 set 메서드로 규칙을 바꿀 수 있게 하였다. 따라서 이후 규칙이 바뀐 게임을 진행하게 된다 해도 손쉽게 적용할 수 있을 것이다.
  - 현재 상태에서는 `룰을 바꾼다`는 내용이 없기에, 생성자 및 set 메서드를 삭제했다. 현재 상태에서 사용되지 않는, 필요없는 메서드를 작성하는 게 옳지 않다고 판단했다. 나중에 룰이 바뀐다는 내용이 추가된다면 그 때 사용해 볼 예정.

- 또한 `play` 메서드에도 숫자를 지정, 룰은 그대로 두고 숫자만 바꿔 결과를 낼 수 있게 하였다.
- 메서드 이름도 `자릿값을 구해 전달하는 메서드` 자체를 `countClap`으로 지정해 `게임을 진행하면서 박수친 횟수를 구하는구나`로 이해할 수 있게 했다.

## Problem4

### 기능 목록

- 해당 규칙을 생성
- 주어진 word를 순회하며 변환 과정을 통해 결과에 추가
- 규칙을 통해 글자를 변환

### 고려한 점

- 규칙은 초기에 한 번만 생성되어야 한다.

### 고민한 사항

- 청개구리의 규칙은 글자를 치환하는 형태이므로, static에 한 번 올리면 변화할 이유가 없었다. 따로 공식을 둬야 할 지, 아니면 하드코딩으로 만드는 게 나을지 고민이 됐다.
  - 해당 글자를 구성하는 규칙이 변화할 경우(A -> Y, B -> X, C -> W, ...) 하드코딩이라면 다시금 갈아엎어야 했다.
  - 만약 특수문자 등을 특정한 규칙에 맞게 변환하는 규칙이 새로 생길 경우, 모두 소문자로 만들 필요 없이 `현재 문자`, `시작 기준값`, `끝 기준값`으로 알아서 처리하도록 하는 게 나을 것 같았다.
  - 따라서 해당 메서드를 구현하기로 결정했었으나, 규칙 역시도 매번 글자가 들어올 때마다 계산할 필요가 없다고 생각했다. 따라서 초기 규칙 생성 메서드를 정의했다.
  - 그러나 이마저도 맘에 들지 않았다. 매번 solution 메서드를 작성시킬 때마다 규칙을 생성할 필요가 없어 보였다. 구글링 중 `클래스 초기화 블럭`에 대해 알게 되었다. 클래스가 초기화될 때에 딱 한번 작동된다는 점이 맘에 들었다. 따라서 해당 방법을 사용하기로 했다.

### 리팩터링

- 청개구리 객체를 만들고, 기본 생성 시 문제의 규칙을 만들 수 있게끔 하였다. 또한 단어를 변환하는 규칙을 생성자 및 set 메서드를 통해 변경할 수 있게 하였다.
  - 이 역시 생성자 및 set 메서드로 규칙 제정하는 부분을 삭제.


## Problem5

### 기능 목록

- 화폐 종류 수만큼 반복하며 인출
- 액수에서 화폐로 변환, 리스트에 추가
- 변환한 금액만큼 차감

### 고려한 점

- 변환할 화폐 단위는 초기에 지정되어 있어야 한다.
- 화폐를 인출하면, 인출한 갯수만큼 저장되어야 한다.
- 남은 금액은 전체 금액에서 인출한 금액만큼 차감되어야 한다.
  - `/`와 `%`를 쓰면 간단하게 구현 가능

### 고민한 사항

- `남은 금액을 반환`하는 메서드에서 `인출한 갯수만큼 리스트에 저장`하는 메서드를 호출하였다. 이 역시 옳은 구조인지 잘 모르겠다.
- 알고리즘 자체는 워낙 유명해서 금방 작성할 수 있었는데, 메서드 이름에 대해 계속 고민하고, 번역기도 여러 번 돌렸다. 기존에는 메서드명을 고민 없이 아무렇게나 지었다는 뜻이 아닐까. 많이 노력하고, 또 익숙해져야 할 것 같다.

### 리팩터링

- 은행 객체를 만들고, 화폐 금액과 인출할 금액으로 결과를 얻을 수 있게 변경했다.

## Problem6

### 기능 목록

- 크루들의 이메일-닉네임 리스트를 순회하며 Map에 데이터 추가
  - 크루들의 닉네임 중 두 글자씩 끊어 Key로 생성
  - Key로 접근한 Value Set에 이메일 주소를 추가
    - 기존 이메일 Value Set 또는 new Set에 크루의 email을 추가
- 닉네임 중 같은 글자가 연속적으로 포함된 크루들을 확인(Value Set 원소 2개 이상)
  - 결과 Set에 해당 Set을 추가하여 합집합 구성
- Set을 List로 전환
- List를 정렬

### 고려한 점

- 크루의 최대 인원은 10000명이다.
- 닉네임의 최대 길이는 19자이며, 두 글자씩을 구하면 18개이다.
- 10000 * 18 = 180000, 충분히 할 만한 양이다. 따라서 두 글자씩 잘라 HashMap을 구현하는 건 시간 내에 가능하다.
- 만약 크루의 최대 인원이 천만명, 닉네임의 최대 길이가 10000자라면..?
- 10000000 * 9999 = 99990000000, 오래 걸릴 것이다.. 해당 구조에서도 빠른 알고리즘은 무엇이 있을까?
- 바로 떠오르지 않으므로 우선 첫번째 알고리즘을 구현해보기로 했다..

### 고민한 사항

- Map과 메서드의 이름을 어떻게 할 것인가
  - 무려 1번 문제를 풀 때부터 고민했던 사항인데, 이제야 감이 좀 잡힐 것 같다.
  - 크루들의 리스트를 순회하며 `닉네임 두 글자 : 이메일 Map`을 작성하는 건 하나의 메서드다.
  - 해당 메서드 내부에서 `닉네임 두 글자 Key`를 만드는 것 또한 하나의 메서드이며, `이메일 Set Value`를 만드는 것 또한 하나의 메서드이다.
  - 즉, `순회하며 Map 만들기` 내부에 `Key 만들기`, `Value 만들기`의 구조로 생성되는 형식이므로 메서드 이름은 해당 메서드가 실행할 전체적인 기능을 담을 수 있게끔 하는 게 좋을 것 같다.
  - 7번까지 다 풀고, 처음부터 리팩터링을 쭉 하는 게 좋을 것 같다.

### 리팩터링

- 닉네임을 업로드하는 방식으로 생각하여, 닉네임을 받는 객체를 만들고 업로드 시 정리하여 중복된 닉네임을 가진 유저들을 반환하게 하였다.

## Problem7

### 기능 목록

- 전체 친구 목록을 정리
  - `이름 : 친구들` 목록 생성
    - 이름에 대한 데이터가 있다면 친구 추가, 없다면 생성 후 추가
  - 특정 유저의 친구 목록을 반환
    - 사용자의 친구 목록 확인
    - 친구들의 친구 목록 확인
- 점수 부여
  - `이름 : 점수` 목록 생성
    - 함께 아는 친구의 점수를 정리
    - 방문자 점수 정리
- 점수 목록 중 이미 친구인 사람 및 사용자 본인 제거
- 점수, 이름순으로 정렬

### 고려한 점

- 친구의 친구 목록이 필요하다.
- 친구들은 친구 추천에 뜨지 말아야 한다.
- 자기 자신은 친구 추천에 뜨지 말아야 한다.

### 고민한 사항

- 이것 역시, 친구가 엄청나게 많은 상황이라면 스캔하기 쉽지 않다. 순회가 아닌, 더 좋은 방법이 있을까?
- 메서드를 작성하다 문득, 따로 클래스를 두고 거기서 관리하면 어떨까 생각했다. `putFriends(totalFriensMap, friends)` 보다는 `totalFriensMap.put(friends)`가 훨씬 직관적으로 다가올 수 있을 것 같았다. 따라서 한 번 시도해보기로 했다.
  - 그러나 클래스를 만들고 나니, 7번 문제에서만 사용할 수 있는 클래스가 만들어진 것 같아 고민된다. 클래스를 쓰는 이유에 맞지 않게 구현한 것이 아닐까? 재사용성 관점에선 나쁜 구조가 아닐까? 물론 해당 클래스를 사용할 수 있는 범위가 현재 7번 문제로 제한이 되어 있지만.. 그래도 단지 가독성을 이유로 해당 방법을 택하지 않았나 생각이 든다. 더 나은 방향으로 생각할 수 있는 힘을 길러야 할 것 같다.
  - 해당 고민은 내 자신이 객체지향과 자바에 대해 아직 이해도가 부족하다는 뜻인 것 같다. 역시, 기본기를 탄탄하게 가져가야 나중에 흔들리지 않는 것 같다. 차근차근 공부하며 단단해져야겠다.

- 우선은 7번 문제를 해결한 후, 모든 문제들을 클래스 사용 방식으로 리팩터링했다. 전보다 훨씬 더 깔끔한 구조가 된 것 같다.

### 리팩터링

- 유저추천 클래스가 유저관계 클래스의 결과를 받아 작업하는 형태이다보니, 따로 있어야 하는지 고민했다. 둘이 맡은 시스템은 다르지만, 한 쪽이 종속된 느낌이라 하나로 합치고 가독성이나 흐름을 더 잘 파악할 수 있게끔 수정했다.
- 하지만 실제 프로젝트를 할 때에는 따로 있는 게 더 낫지 않을까..? 종속 관계를 제거하고 둘을 따로 관리하는 게 클린코드에 더 가깝지 않을까 생각했다. 해당하는 방향에 대해서도 공부해봐야겠다.

---

# Git

## Git Convention

[git-cz](https://www.npmjs.com/package/git-cz)를 사용하여 타입에 따른 이모지를 추가했다. 또한 [해당 블로그](https://overcome-the-limits.tistory.com/6)의 메시지 구조로 작성해보려 노력했다.

전에도 git-cz를 사용했지만, 커밋 메시지를 고민하지 않고 막 적었던 것 같다. 주로 제목은 기능을, 본문은 기능의 상세내용을 작성하는 형태였는데 따로 약속을 정해서 작성한 적은 없던 것 같다. 이번 기회에 제대로 작성해보도록 했다.

### 제목

고침, 추가, 변경의 명령어로 시작. 어떠한 것을 작성하였는가.

### 본문

양에 구애받지 않고 최대한 상세히. 무엇을, 왜 작성했는지 설명

### Breaking Change

API, DB 테이블, 치명적인 버그 수정 등 급격한 변화 내용

### issues this commit closes

해당 커밋으로 인해 종료할 이슈. 아직 이슈를 제대로 다뤄본 적이 없다. 이번에 이슈를 다루지 못 하더라도, 다음주부터 피드백 관련 이슈를 생성하고 실습해보면 좋을 것 같다.

---

# 느낀 점

- 지금까지는 알고리즘 문제를 풀 때, 구성은 고려하지 않은 채 마구 코드를 작성했었다. 그러다 보니 이번 프리코스 1주차 역시도 그렇게 하면 될 거라 생각했다.
- 허나, 기능 구현 전 기능 목록을 만들고 기능 단위로 커밋을 수행하려니 턱턱 막히는 부분이 많았다. 어디까지 쪼개야 하며, 어떻게 진행시켜야 할 것인가? 고민하는 시간이 알고리즘 해법을 생각하는 시간보다 훨씬 길었다.
- 또한, Slack에서 많은 분들의 질답과 의견을 보면서 배우는 점이 많았다. 처음부터 다른 사람이 볼 것을 염두해 두고 작성한다는 것이 상당히 힘든 부분임을 알 수 있었다. 기존 프로젝트들을 수행하면서는 `내가 맡은 부분이니, 내가 알아볼 수 있으면 된다!`하며 작성했었는데, 이는 미래의 나조차도 이해하기 힘들게 했으며 어떤 코드가 어디까지 영향을 끼치는지도 확신할 수 없었다. 현재 프로젝트 하나를 리팩터링 중인데, 프리코스에서 배운 클린코드적 관점을 되새기며 리팩터링해보는 것도 좋은 경험이 될 거라 생각했다.
- 기존 프로젝트를 진행할 때, 깊은 고민을 제대로 해본 적이 없다는 것을 깨달았다. 그저 빠른 답을 내기 위해, 모든 코드들을 알고리즘 문제 풀듯 진행했던 것 같다. 구글링 결과를 복붙하거나, '이렇게 하면 돌아가니까' 하며 작성했었다. 많은 반성을 하게 된다.
- 역시나, 코드를 구성해보면서 느낀 건 `기초가 튼튼해야 한다`였다. 내가 내 코드를 믿지 못 하게 되니 리팩터링을 하면서도 자꾸 의심하게 된다. 어떠한 방향이 옳은 지향점인지 계속 프리코스에 참여하며, 또 개인적으로 공부하며 알아가봐야겠다.
