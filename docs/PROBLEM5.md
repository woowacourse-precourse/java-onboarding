### 문제 접근.
*하나의 메소드에 하드 코딩으로 풀어도 무방한 문제지만, 시험 문제를 푸는게 아니라 개발 작업을 한다 생각하고 중복된 코드의 반복을 막아보자.*  
- money는 1 이상 1,000,000 이하인 자연수이다. : Integer의 범위인 21억에도 미치지 못하는 숫자이므로 타입에는 신경쓰지 않아도 될 것이다.  

해당 문제는 친절하게도 모든 돈의 단위가 10의 배수로 설정되어 있다.  
그리고 돈의 단위 당 무게에 대한 언급이 없으므로 단위 별 무게가 동일하다고 생각하자. 실제 테스트케이스에도 통과하니 무게라는 가중치는 없다고 판단하는게 옳은 것 같다.  
그렇다면 이 문제는 단위가 큰 지폐 먼저 채워가는 그리디 형식으로 풀어갈 수 있다.  

해당 문제는 코드가 짧고 기능도 적어서 메소드 단위로 코드를 분할하는 것이 오히려 가독성에 안좋을 것이라 판단했다.  
변수들을 전역으로 올린다면 코드 분할도 괜찮겠지만, 전역 변수의 사용은 최소한으로 하기 위해 다루지 않았다.  
단, 화폐 단위를 다루는 배열은 전역으로 두었다.  

### 기능 목록
- [x] 큰 화폐 단위부터 잔액에서 차액  
화폐 단위로 잔액을 나눈 다음, 잔액 변수에 차액을 저장하고, 얻은 화폐를 List에 저장했다.  
- [x] 전체 화폐 단위 순회  
화폐 단위를 배열에 담아 전역 변수로 설정했다. 만일 단위가 추가된다면 배열에 추가하면 될 것이다. (물론 정렬도 수행해야 할 것이다.)  
해당 배열의 크기만큼 순회를 수행하여 결과를 얻었다.  

---  

## 🚀 기능 요구 사항

계좌에 들어있는 돈 일부를 은행에서 출금하고자 한다. 돈 담을 지갑이 최대한 가볍도록 큰 금액의 화폐 위주로 받는다.

돈의 액수 money가 매개변수로 주어질 때, 오만 원권, 만 원권, 오천 원권, 천 원권, 오백원 동전, 백원 동전, 오십원 동전, 십원 동전, 일원 동전 각 몇 개로 변환되는지 금액이 큰 순서대로 리스트/배열에 담아 return 하도록 solution 메서드를 완성하라.

### 제한사항

- money는 1 이상 1,000,000 이하인 자연수이다.

### 실행 결과 예시

| money | result |
| --- | --- |
| 50237	| [1, 0, 0, 0, 0, 2, 0, 3, 7] |
| 15000	| [0, 1, 1, 0, 0, 0, 0, 0, 0] |