## 🚀 기능 요구 사항

암호문을 좋아하는 괴짜 개발자 브라운이 이번에는 중복 문자를 이용한 새로운 암호를 만들었다. 예를 들어 "browoanoommnaon"이라는 암호문은 다음과 같은 순서로 해독할 수 있다.

1. "browoanoommnaon"
2. "browoannaon"
3. "browoaaon"
4. "browoon"
5. "brown"

임의의 문자열 cryptogram이 매개변수로 주어질 때, 연속하는 중복 문자들을 삭제한 결과를 return 하도록 solution 메서드를 완성하라.

### 제한사항

- cryptogram은 길이가 1 이상 1000 이하인 문자열이다.
- cryptogram은 알파벳 소문자로만 이루어져 있다.

### 실행 결과 예시

| cryptogram | result |
| --- | --- |
| "browoanoommnaon" | "brown" |
| "zyelleyz" | "" |


<br>

## 기능 목록 Ver.2 (반영 완료/단일 기능)
### 1. 문자열의 앞부터 확인하여 연속하여 중복이라면 제거하도록 구성
#### 앞부터 확인하며 중복되지 않는 문자열만 남기고, 다시 앞부터 확인하며 중복되는 문자열을 제거하는 과정을 반복한다.
    1. answerlist의 처음 원소부터 순회하며 next가 curr과 같은지 확인한다.
    2. next가 curr과 같다면 이는 다음 반복 대상에 포함시키지 않는다.
    3. next가 curr과 다르다면 duplicate을 확인하여 curr을 추가시킬지 판단한 후 curr 문자를 next 문자로 변경한다. 
    4. 문자열의 끝까지 동일한 과정을 반복한 후 더이상 수정사항이 없다면 문자열로 반환한다.

#### ver1 과 다른 점은 중복된 문자를 2개로 한정하지 않았다는 점입니다. 문제 해석이 변화하여 코드도 대폭 수정했습니다.
#### 아래 기존의 ver 1 기능 설명을 첨부합니다.

<br> <br>

## 기능 목록 Ver.1 (단일 기능 / 제거 완료)
### 1. 문자열의 앞부터 확인하여 연속하여 중복이라면 제거하도록 구성
#### 스택을 생성하고, 연속하여 중복되지 않는다면 스택에 추가한다.
    1. i=0으로 초기화한 후 문자 형식 next에 문자열의 i번째 문자를 대입한다.
    2. 스택이 비어있다면 next를 스택에 넣고 i를 1 증가시킨다.
    3. 스택의 원소가 있다면 스택의 마지막 원소를 pop하여 next와 비교한다. 
    4. 3번에서 두 문자가 일치한다면 두 원소를 모두 제외하고(i만 1 증가시키면 된다.) 그렇지 않다면 pop한 원소와 next를 스택에 추가한다.

#### 이후 스택의 원소를 문자열로 변환한다.
