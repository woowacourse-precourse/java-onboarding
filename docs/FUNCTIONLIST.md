# Problem 1
### 포비와 크롱을 User라고 칭한다.
- [x] 주어진 각 User의 리스트/배열의 각 자리 숫자를 모두 더하는 기능
- [x] 주어진 각 User의 리스트/배열의 각 자리 숫자를 모두 곱하는 기능
- [x] 위 두 기능의 계산 결괏값에서 최댓값을 찾는 기능
- [x] 주어진 각 User의 리스트/배열의 최댓값을 비교해 pobi의 최댓값이 더 크면 1을 crong의 최댓값이 더 크면 2, 무승부는 0을 return 하는 기능

###예외 사항은 -1을 return 하는 것이며 아래 기준들에 부합하지 않으면 발생시킨다.
- [x] 주어진 각 User의 리스트/배열의 각 요소가 페이지 범위에(1 이상 400 이하) 속하는지 확인하는 기능
- [x] 주어진 각 User의 리스트/배열의 첫 번째 요소가 홀수인지 확인하는 기능
- [x] 주어진 각 User의 리스트/배열의 (첫 번째 요소 + 1)의 값이 두 번째 요솟값과 같은지 확인하는 기능

# Problem 2
### 문제 풀이 방법,
#### 스택 구조를 활용한다. 문자열을 순회하면서 현재 보고있는 문자를 스택에 넣을 때 스택 최상단에 있는 문자와 일치하는지의 여부를 판단한다. 만약 일치하는 문자가 스택의 최상단에 있다면 pop , 없다면 push를 진행한다. 이후 스택에 남아있는 문자를 순서대로 출력하면된다.
- [x] 스택이 비었는지 확인하는 기능
- [x] 비어있지 않을 경우 스택의 최상단 문자를 확인하는 기능
- [x] 스택의 최상단 문자와 현재 보고있는 문자를 비교하는 기능
- [x] 비교한 문자가 같으면 스택의 최상단 문자를 삭제하는 기능
- [x] 비교한 문자가 다르면 스택에 삽입하는 기능
- [x] 스택의 내용을 출력하는 기능

# Problem 3
- [x] 순회하는 숫자를 String으로 바꾸는 기능
- [x] 바꾼 문자열에서 '3', '6', '9'의 갯수를 세는 기능
- [x] 해당 값을 정답에 더함

# Problem 4
### 문제 풀이 방법,
#### 주어진 문제의 청개구리 사전은 A에서Z의 각 요소가 의 A에서 Z역순으로 매칭되어있다. 이 점을 활용하여 아스키코드를 통해 풀이한다.
- [x] 문자가 주어지면 역순으로 위치한 문자로 반환하는 기능, 공백은 그대로 반환한다.

# Problem 5
### 문제 풀이 방법,
#### 모든 금액은 해당 금액보다 작은 금액으로 모두 나누어 떨어지기 때문에 항상 큰 금액을 먼저 가져가면 지갑이 가볍도록 만들 수 있다.
- [x] 주어진 money를 주어진 금액으로 나눈 몫 반환 하는 기능
- [x] 주어진 money를 주어진 금액으로 나눈 나머지 반환 하는 기능
- [x] 위 결과값을 주어진 금액에 맞게 List에 저장하는 기능

# Problem 6
### 문제 풀이 방법,
#### 해시맵을 이용하여 해당 ID를 추가할 때 중복되어 있으면 answer에 추가하는 방식으로 한다.
#### 연속되는 글자는 2개씩만 확인해도 된다.
- [x] 주어진 닉네임을 2개씩 잘라 List로 만드는 기능
- [x] 해당 List를 순회하며 해시맵에 key = 닉네임, value = 이메일이 되도록 추가한다.
- [x] 추가할 때 기존 해시 맵에 해당 key가 존재하고, 이메일이 다르면 중복 이메일로 둘 다 answer에 추가한다.
- [x] answer의 중복을 없애고 오름차순으로 정렬한다.

# Problem 7
### 문제 풀이 방법,
#### user와 연결된 친구와 연결된 친구가 10점을 가지게 되는 것이다.
#### 양방향 그래프를 만들고 user로 부터 2칸을 탐색하도록 구현한다.
- [ ] friends, visitors로 HashMap을 만드는 기능 (result에 사용, user 제외) 
- [ ] user와 friends로 그래프를 만드는 기능
- [ ] user부터 순회하며 2칸 떨어진 친구에게 10점을 추가하는 기능
- [ ] visitors를 순회하며 방문한 사람에게 1점을 추가하는 기능 
- [ ] 0을 제외한 최대 5명을 뽑고, 점수가 높은 순으로 정렬하여 최대 5명을 return하는 기능(점수가 같으면 이름순 정렬)