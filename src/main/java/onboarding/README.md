<h1>😁 1주차 미션 - 온보딩</h1>
<h2>문제 1 </h2>
<h3>📋 기능목록</h3>
<pre><code>
1. 포비와 크롱이 각각 펼친 페이지 수를 수식에 기반한 최대값 계산 기능
2. 주어진 페이지에 대한 유효성 검사를 하는 기능
3. 각각의 최대값을 비교하여 승자를 반환하는 기능
</code></pre>
<h3>✏ 느낀점</h3>
<pre><code>
우선 친숙한 이름들이 나와 반가웠다.. 문제 난이도는 그닥 어렵지 않았다. 그러나 많은 예외 조건들을 생각하다보니, 코드가 조금 길어져
클래스를 따로 구분하여 관리하였다. 조건문을 반복해서 검증해야 할 필요가 있었는데, 한 줄로 표현하기 보다, 많은 사람들이 사용하는 조
건문 형식으로 작성해야 잘 읽힐 꺼라는 생각이 들어서 조건문을 늘려서 작성했다. 나만 보는 코드가 아닌, 다른 사람들도 같이 보는 코드라고
생각해서 작성하니, 시간이 더 소요가 되지만, 그런 생각을 해보며 코드를 작성한다는 게 좋은 경험이 되었다! 👍
</code></pre>

<h2>문제 2 </h2>
<h3>📋 기능목록</h3>
<pre><code>
1. 주어진 문자열을 Stack에 저장하는 기능
2. 증복이 검출되었을 때, 중복횟수를 증가시키는 기능
3. 증가돤 중복횟수를 기반으로 중복된 문자를 Stack에서 제거 기능
4. 반복하여 중복된 문자 제거 후, 중복이 없을 경우 해당 문자열을 반환하는 기능
</code></pre>
<h3>✏ 느낀점</h3>
<pre><code>
개인적으로 조금 난이도가 있었던 문제였다. 하지만 문제를 자세히 보니, 과정을 설명해주신 점이 큰 도움이 되었다. 처음엔 두 문자만 처리
중복을 처리하는 줄 알았지만, 문제를 다시보니 2개 이상의 중복된 문자를 처리하는 것이었다. 그렇게 간단했던 로직에 수많은 조건들이 덧붙기
시작했다... ( 조건문 지옥에서 꺼내주세요 ) 쌍쌍바 처럼 붙어있는 for문과 if문은 정말 개발자를 힘들게 하는 것 같다. 하하 😂 
</code></pre>

<h2>문제 3 </h2>
<h3>📋 기능목록</h3>
<pre><code>
1. 주어진 박수 조건을 기반으로 횟수를 반환하는 기능 추가
2. 각각 3.6.9 번째에 해당하는 조건을 대입하여 그 더한 값을 반환하는 기능
</code></pre>
<h3>✏ 느낀점</h3>
<pre><code>
1..2..짝! 비교적 쉽게 풀 수 있었다. 문제를 보고 단박에 1의 자리 뿐만이 아닌, 10의 자리 100의 자리의 3,6,9에도 조건을 줘야한다
는 것을 알았다. 그렇다고 369 게임을 잘하는 건 아니다. 그냥 많이 보던 문제일 뿐.. ( 술 마시러 갈때 빌드해서 가야겠어요 😳 )
</code></pre>

<h2>문제 4 </h2>
<h3>📋 기능목록</h3>
<pre><code>
1. 주어진 문자를 청개구리식으로 변환하는 기능
2. 변환된 청개구리식 문자를 대문자, 소문자로 각각 변경하는 기능
3. 해당 로직을 반복하여 모든 문자를 청개구리식으로 변환하는 기능
4. 알파벳이 아닌 경우를 검증하는 기능
</code></pre>

<h3>✏ 느낀점</h3>
<pre><code>
[문제 4]도 간단하게 풀었다. 청개구리는 반대로 말하니까 배열을 거꾸로 생각하면 풀 수 있는 문제였다. 조금 더 생각해봐야하는 부분은 
대문자를 대문자로, 소문자를 소문자로 변경해야 하는 부분이고 영어 이외의 문자는 그대로 출력해야 하는 부분이다. 물론 공백도 포함되
는 이야기이다. 이런 점들은 주의하면 쉽게 풀 수 있는 문제같다 ysae! 🐸 
</code></pre>

<h2>문제 5 </h2>
<h3>📋 기능목록</h3>
<pre><code>
1. 기본적인 현금 별 개수 List 생성
2. 반복문을 통해 현금 각각의 갯수를 계산하여 반환
</code></pre>
<h3>✏ 느낀점</h3>
<pre><code>
[문제 5]를 보고 숫자와 난이도는 비례하는 게 아니라고 생각했다. 아마 7문제 중 가장 쉬웠던 문제같다. 주의해야할 부분도 다른 문제보다
많이 없었다. 가장 적은 코드로 풀 수 있는 간단한 문제였다~ 그리고 이런 일이 없도록 카드를 사용합시댜 
</code></pre>

<h2>문제 6 </h2>
<h3>📋 기능목록</h3>
<pre><code>
1. 닉네임을 2문자씩 잘라 HashMap에 저장하는 기능
2. crew의 닉네임을 모두 2문자씩 잘랐을 때 자른 값이 HashMap에 있다면 중복 이메일 리스트에 추가하는 기능
3. 중복 이메일 리스트의 중복 값을 제거한 뒤, 오름차순으로 정렬하는 기능
</code></pre>
<h3>✏ 느낀점</h3>
<pre><code>
[문제 5]에서 느꼈던 문제 번호와 난이도는 반비례하다는 생각이 곧바로 무너졌다. 역시 쉽지 않은 문제였다. 2번에 이어 가장 시간이 오래
걸린 문제였다. 처음에 닉네임을 두 문자씩 잘라서 구분해야 한다는 생각은 했지만, 이를 어떤 자료구조로 관리해야 하는지 감이 안 잡혔다.
모든 Crew의 닉네임을 검사하기 때문에 Map의 key로 넣어놓고, containsKey() 메소드를 이용해서 검사하는 방법을 선택했다. 또한 처음엔 
중복이 되지 않아도, 추후에 검사되는 Crew의 닉네임으로 인해 중복이 될 수 있기 때문에 value 값에 자른 문자의 닉네임을 가지고 있는 Crew
의 이메일을 넣어두었다. 그렇다 느낀바는 느낀점의 라인 수와 비례하다. 🤣
</code></pre>

<h2>문제 7 </h2>
<h3>📋 기능목록</h3>
<pre><code>
1. 사용자의 친구와 사용자와 친구가 아닌 관계를 분리하는 기능
2. 사용자와 친구가 아닌 관계 중 사용자의 친구와 관계인 이들을 추천 친구로 등록 및 점수를 부여 (+10점)
3. 사용자의 타임라인에 방문한 이들에게 추천 친구 등록하고 점수 부여 (+1점)
4. 추천 친구로 등록된 이들 중 점수가 높은 순으로 정렬하고 같으면 이름순으로 정렬하여 반환
</code></pre>
<h3>✏ 느낀점</h3>
<pre><code>
엄청나게 난이도가 있을 거 같았던 [문제 7]은 비교적 간단하게 풀었다.
[ 1.친구관계 분리, 2.함께 아는 친구 점수 부여, 3.방문 점수 부여 ] 이렇게 3가지로 나누어 생각하니, 로직이 술술 나왔다.
예외적인 상황도 무리없이 구현할 수 있었다. 다소 헷갈리는 개념(함께아는 친구)이 섞여서 있어서 문제를 어떻게 잘 이해하느냐가
중요한 것 같았다! 
</code></pre>




