### 문제 접근.  
*하나의 메소드에 하드 코딩으로 풀어도 무방한 문제지만, 시험 문제를 푸는게 아니라 개발 작업을 한다 생각하고 중복된 코드의 반복을 막아보자.*  
- cryptogram은 길이가 1 이상 1000 이하인 문자열이다. : 만약 이 문제를 완탐한다면 최대 1000!의 순회가 필요하다.
이 문제는 중첩되는 동일한 알파벳을 제거해나가는 문제다. 그렇다면 문자열의 문자를 하나씩 저장해나가다 마지막 저장한 문자와 들어오는 문자가 같은지 검증한다면 매번 문자열 전체를 순회할 필요가 없다. 이에 가장 적합한 구조는 스택(Stack)이다.  
최종적인 문자열은 스택을 하나씩 ```pop()```하여 ```StringBuilder```에 저장하고 ```reverse()```로 뒤집어서 도출한다.  
- cryptogram은 알파벳 소문자로만 이루어져 있다. : 이 조건을 이용하여 문자열의 첫 문자가 stack에 들어올 때 빈 stack을 peek하는 문제를 처리하겠다.  

문제를 풀며 리팩토링하며 기억나는 것으로 어디에서도 해독기를 불렀을 때 동일한 값을 줘야 한다고 생각하여 싱글톤 패턴을 사용했었다.  
하지만 다시 생각해보니 그렇다면 만약 다른 곳에서 호출했을 때 지금 작업중인 객체의 필드가 사라지므로 말도 안되는 생각이었다. 결국 롤백했다.  

### 기능 목록
- [x] 스택 자료구조 생성  
암호문을 푸는 해독기 ```Decrpyt```클래스를 생성하고 ```Decrypt()```메소드 하나로 전체 동작을 수행하도록 구조 생성.  
Stack 타입의 ```stack``` 필드를 생성하는데 이 때 초기 문자인 '/'를 넣어준다. 이유는 문자열의 첫 글자가 들어왔을 때도 기존 스택의 ```peek()```를 수행할 텐데 이때
에러를 방지하기 위함이다.  
- [x] 문자열을 순회하며 스택에 저장  
```decrypt()```에서 ```Decrypt```클래스의 필드인 ```stack```에 ```cryptogram```을 순회하며 문자로 나눠 저장  
- [x] 스택에 저장한 이전 문자와 입력할 문자가 동일할 시 둘 다 제거  
```decrypt()```에서 ```stack```의 ```peek()```메소드로 마지막 원소를 제거하지 않고 가져와 현재 입력할 문자와 비교. 같을 시 둘 다 제거, 다를 시 입력.  
*문자열을 순회하며 스택에 넣는 과정과 스택 문자 비교 과정을 나눌 시 스택을 사용하는 장점이 사라지므로 이 기능은 ```decrypt()```에서 함께 처리*  
- [x] 스택에 저장한 이전 문자와 입력할 문자가 다르다면 스택에 저장  
*위의 내용과 동일.*  
- [x] 최종 문자열 도출  
```Decrpyt```클래스의 필드인 StringBuilder 타입의 ```sb```에 저장 후 리턴.  

---  

## 🚀 기능 요구 사항

암호문을 좋아하는 괴짜 개발자 브라운이 이번에는 중복 문자를 이용한 새로운 암호를 만들었다. 예를 들어 "browoanoommnaon"이라는 암호문은 다음과 같은 순서로 해독할 수 있다.

1. "browoanoommnaon"
2. "browoannaon"
3. "browoaaon"
4. "browoon"
5. "brown"

임의의 문자열 cryptogram이 매개변수로 주어질 때, 연속하는 중복 문자들을 삭제한 결과를 return 하도록 solution 메서드를 완성하라.

### 제한사항

- cryptogram은 길이가 1 이상 1000 이하인 문자열이다.
- cryptogram은 알파벳 소문자로만 이루어져 있다.

### 실행 결과 예시

| cryptogram | result |
| --- | --- |
| "browoanoommnaon" | "brown" |
| "zyelleyz" | "" |  



