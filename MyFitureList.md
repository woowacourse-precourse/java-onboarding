
## 1번 문제
1. 예외사항을 먼저 -1로 return 해준다
2. 포비의 왼쪽, 오른쪽크기를 비교하여 큰 수를 포비의 수로 설정하고 크롱도 이와같이 해준다
3. 포비와 크롱의 점수를 비교하여 지정해준 값을 리턴해준다.

예외 처리 사항 
입력페이지가 시작페이지와 마지막 페이지가 들어올 수 있다
입력 페이지의 범위가 책의 페이지보다 크거나 작을 수 있다
왼쪽 페이지가 홀수가 아니거나 오른쪽 페이지가 짝수가 아닐 수 있다
오른쪽 페이지가 왼쪽페이지의 +1이 아닐 수 있다


## 2번 
1. 입력문자열을 char배열로 만든다
2. char배열의 길이만큼 반복하여 i번째 문자열과 i+1번째 문자열이 같다면 인덱스인 i와 i+1 을 모두 set에 담아준다 (중복제외)
3. 2번의 set의 크기가 0이라면 반복문을 빠져나가고, 아니라면 set을 리스트로 변환한다
4. 입력문자열의 배열의 길이에서 중복문자열의 인덱스를 저장한 리스트의 길이를 뺀 새로운 결과값 char 배열을 만들어준다
5. 입력문자열의 배열에서 중복문자열 리스트에 포함이 안된 인덱스의 값만 결과값 배열 안에 담아준다
6. 입력문자열을 결과값 문자열로 초기화하여 반복문을 돌 수 있도록 한다
7. 중복문자열 인덱스 set의 크기가 0이 될때까지 2-7을 반복한다

예외사항 
중복 문자열은 2개이상 일수도 있다
입력 문자열이 1글자인 경우 입력문자열을 그대로 출력하도록 한다


## 3번
1. 각자리 수 마다 3, 6, 9가 포함되어 있다면 카운트를 해준다


## 4번
1. 입력 문자열을 char 배열로 바꿔준다
2. 배열의 크기만큼 반복문을 돌며 대문자와 소문자로 분류하여서 변환하여 저장하도록 한다


## 5번
1. 돈의 액수 배열을 만들어 큰수부터 저장한다
2. 돈의 액수 배돈의 열의 크기 만큼 반복문을 돌아 돈의 액수가 각 인덱스의 돈의 액수로 나눠지면 몫을 리스트에 담아주고, 나머지를 돈의 액수로 저장한다.
3. 돈의 액수가 각 인덱스의 돈의 액수로 나눠지지 않으면 0을 리스트에 담아준다


## 6번
1. 크루의 모든 닉네임을 두글자씩 set에 담아주려 한다 (키값은 닉네임의 각 두글자이고, 밸류는 " "로 한다)
2. 담기 전에 이미 있는 값인지 확인하고 이미 있는 값이하면 중복문자열 리스트에 담아주고, 없는 값이라면 map에 담아준다
3. 크루의 모든 닉네임을 중복문자열 리스트와 비교해주고 (contains), true 가 나온다면 이메일을 set에 담아준다.
4. 이메일 set을 리스트로 바꿔준다
5. 이메일 리스트를 정렬해준다

예외사항
3번에서 중복 이메일을 걸러줘야 한다 (set 사용)


## 7번
1. 사용자 아이디로 friend 리스트에서 친구를 찾아서 리스트로 만든다 (중복값 없음)
2. 사용자의 친구리스트의 크기가 0인 경우와 아닌 경우를 나눠준다

사용자의 친구 리스트의 크기가 0인경우 :
a. 방문객 리스트를 친구의 친구맵에 추가한다 (이미 존재하는 사람이라면 1을 올려주고, 없는 사람이라면 1 포인트와 함께 새로 입력해준다)

사용자의 친구 리스트의 크기가 0보다 큰 경우 :
a. 친구리스트로 친구의 친구 맵을 만들어 포인트를 준다 (중복값 있음 중복이면 점수가 중복인거임!!)
b. a의 맵에서 친구 리스트와 공통된 사람이 있다면 빼준다
c. 방문객 리스트의 크기가 0이아니라면, 친구의 친구맵에 추가한다 (이미 존재하는 사람이라면 1을 올려주고, 없는 사람이라면 1 포인트와 함께 새로 입력해준다)
d. 방문객 리스트의 크기가 0이아니라면, 친구의 친구맵에 중에 친구리스트에 포함된 사람을 뺴준다

3. 이중배열로 {점수, 아이디} 순서대로 담아서 점수 내림차순, 아이디 오름차순으로 정렬해준다
4. 정렬된 배열에서 최대 5명 까지만 담아준다

예외사항 
user의 친구가 한명도 없을 수 있다
visitors는 길이가 0이상이므로 0인 경우도 고려해야 한다 
visitors에 유저 본인이 들어올 수 있다
추천 친구는 최대 5명 까지만 출력한다
