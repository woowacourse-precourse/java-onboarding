### Problem1

1. 예외 처리 메소드 구현<br/>
   1-1. 시작 면이나 마지막 면이 나오면 -1을 return<br/>
   1-2. 왼쪽 페이지와 오른쪽 페이지가 연속되지 않는다면 -1을 return<br/>
   1-3. 왼쪽 페이지가 홀수가 아니거나 오른쪽 페이지가 짝수아니라면 -1을 return<br/>
2. 객체 구현 및 원시값 포장 구현<br/>
   2-1. 객체는 왼쪽 페이지와 오른쪽 페이지를 저장<br/>
   2-2. 객체를 생성하고 페이지를 저장할 때 예외가 발생하면 Exception을 throw<br/>
3. 페이지 번호의 최대값을 구하는 메소드 구현<br/>
   3-1. 각 자리 숫자를 더하거나 곱하여 가장 큰 수를 Math.max()를 이용하여 return

### Problem2

1. 문자열을 char형 배열로 변환
2. char형 배열에서 연속적인 문자 찾기
3. 연속적인 문자의 길이 찾기
4. 연속적인 문자에 해당하는 인덱스에 길이만큼 0으로 변환
5. 변환된 char형 배열을 문자열로 바꾸어 반환
6. 연속적인 문자를 제거하였다면 1번부터 다시 진행
   6-1. 연속적인 문자를 제거하지 않았다면 문자열 반환 후 종료

### Problem3

1. 1부터 숫자를 생성
2. 생성된 숫자가 3, 6, 9가 몇 개씩 들어가는지 반환
3. 반환된 숫자를 answer에 더하기
4. 1~3번 과정을 1부터 주어진 number까지 수행 
5. answer을 반환

### Problem4

1. word를 char형 배열로 변환
2. 배열 원소값이 영어 알파벳이라면 개구리 사전을 적용
3. 완성된 char형 배열을 문자열로 변환하여 반환

### Problem5

1. money를 큰 금액 순서대로 나눈 수를 answer에 추가
2. money를 큰 금액으로 나눈 나머지를 money로 수정
3. 오만 원권 부터 일원 동전까지 1,2번을 수행한 후 answer를 return

### Problem6

1. 리스트에서 이름을 꺼내고 이름에서 연속된 2개의 문자씩 전달하는 메소드 구현
2. 넘겨받은 2개의 문자를 넘겨준 이름을 제외한 리스트에서 포함하는지, 포함한다면 해당처리
3. 1,2번을 수행하여 넘겨받은 해당 리스트를 answer 리스트에 추가 후 반환
4. answer 리스트를 정렬

### Problem7

1. 사용자를 아는 친구를 목록에서 제외, 함께 아는 친구라면 목록에 추가 후 10점씩 추가<br/>
   1-1. 사용자를 함께 아는 친구가 함께 아는 친구를 n명을 안다면 n * 10 점을 추가한다.<br/>
2. 사용자를 방문한 함께 아는 친구의 방문 횟수 n 당 n * 1 점 추가
3. 친구 점수를 통해 큰 점수 순서대로, 같은 점수라면 사전순으로 정렬
4. 정렬된 리스트를 반환