### 문제 접근.
*하나의 메소드에 하드 코딩으로 풀어도 무방한 문제지만, 시험 문제를 푸는게 아니라 개발 작업을 한다 생각하고 중복된 코드의 반복을 막아보자.*  
- number는 1 이상 10,000 이하인 자연수이다. : 일반적으로 알고리즘 문제를 풀 때 1억번의 연산을 1초로 가정하면 안전하다.  
이 문제의 경우는 1~10000의 범위이므로 완전탐색으로 풀 수 있다.  

369가 포함된 숫자마다 박수를 한번 치는게 아닌 포함된 횟수만큼 치는 것에 유의하자.  
예를 들어 33일 경우, 박수를 1번이 아닌 2번 치는 것이다.  


### 기능 목록
- [x] 1부터 입력된 수까지 순회  
결과값 변수와 1부터 입력된 수까지 순회는 ```solution()```에서 동작.  
- [x] 3 6 9 횟수별 박수를 계산하기 위해 자리수 별 숫자 파악  
자리수를 파악하기 위해 ```Math.pow()```를 이용하여 현재 숫자가 10의 제곱수보다 작은지로 판별.  
해당 내용은 ```digitNumber()```에서 처리.  
- [x] 3 6 9에 해당하는지 검증  
자리수로 나눠진 숫자가 ```needCrap()```에서 3 6 9에 해당하는 숫자인지 검증하여 ```Boolean```으로 리턴해준다.  
*해당 문제에서는 3 6 9의 3가지 숫자로 한정되었지만 혹시 모를 문제의 확장을 위해 3 6 9를 정수 배열에 담아 전역 변수로 설정했다.*  
- [x] 박수 횟수 도출  
박수를 쳐야하는 숫자에 해당한다면 결과를 담는 ```result```변수에 +1 연산을 해주었다.  



---  


## 🚀 기능 요구 사항

배달이가 좋아하는 369게임을 하고자 한다. 놀이법은 1부터 숫자를 하나씩 대면서, 3, 6, 9가 들어가는 숫자는 숫자를 말하는 대신 3, 6, 9의 개수만큼 손뼉을 쳐야 한다.

숫자 number가 매개변수로 주어질 때, 1부터 number까지 손뼉을 몇 번 쳐야 하는지 횟수를 return 하도록 solution 메서드를 완성하라.

### 제한사항

- number는 1 이상 10,000 이하인 자연수이다.

### 실행 결과 예시

| number | result |
| --- | --- |
| 13 | 4 |
| 33 | 14 |
