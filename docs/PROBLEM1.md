### 문제 접근.
[1 ~ 400] 범위의 페이지. 그러나 우리가 구할 것은 제시된 케이스로 인물 별 하나. 고로 범위는 예외사항 처리용도.
문제에서 요구하는 대로 구현하는 시뮬레이션 문제.  
하나의 메소드에 하드 코딩으로 풀어도 무방한 문제지만, 시험 문제를 푸는게 아니라 개발 작업을 한다 생각하고 중복된 코드의 반복을 막아보자.
일반적인 알고리즘 문제에선 하지 않았지만, 중복된 코드 반복을 줄이면서 함수의 depth도 얕게 구현해보자.


### 기능 목록
- [x] 게임 승패 계산  
  ```playGame()```에서 두 플레이어의 페이지가 List<Integer> 타입으로 인자 들어옴.
  리스트에 있는 각 페이지를 ```calcScore()```를 통해 점수화한 결과를 ```resultGame()```에서 결과 도출.  
- [x] 인물 별 가장 큰 점수 계산  
```calcScore()```에서 한 플레이어의 페이지 정보가 담긴 List<Integer>를 받아서 계산.
리스트를 순회하며(좌, 우 페이지를 확인하며) 각 페이지별 덧셈과 곱셈의 점수를 ```compareScore()```를 통해 계산하여 보다 큰 값을 점수로 삼는다.  
- [x] 유효한 페이지인지 검증(예외 처리)  
```verifyGame()```에서 각 플레이어의 페이지 정보 List<Integer>를 받아서 유효한 데이터인지 파악한다. 하나의 검증에도 유효하지 않다면 -1 리턴.  
  - [x] 시작 면과 마지막 면이 나왔는가?  
  ```verifyEdgePage()```에서는 문제에서 정의된 첫 페이지와 마지막 페이지가 나오지 않는다가 확실한지 검증한다.  
  - [x] 연속된 페이지가 아닌가?  
  ```verifyContinuePage()```에서는 좌측 페이지와 우측 페이지가 연속된 페이지인지 검증한다.  
  - [x] 왼쪽 페이지가 홀수, 오른쪽 페이지가 짝수가 아닌가?  
  ```verifyOddEven()```에서는 문제에서 정의된대로 좌측 페이지가 홀수, 우측 페이지가 짝수인지 검증한다.  
  - [x] 페이지의 범위 [1~400]을 벗어나는가?  
  ```verifyPageBoundary()```에서는 문제에서 정의된 페이지의 범위를 넘어서는지 검증한다.  
- [x] 페이지를 각 자리 숫자로 분해하여 배열 저장  
```intToArr()```에서는 int 타입의 하나의 페이지를 자리수 별 덧셈과 곱셈을 용이하게 하기 위해 배열에 나눠 담는 기능을 수행한다.  
- [x] 각 자리 숫자의 곱셈과 덧셈 중 큰 점수 도출  
```compareScore()```에서는 배열에 담긴 페이지의 자리수 정보를 토대로 곱셈과 덧셈 연산을 진행 후 보다 큰 값을 점수로 리턴한다.  
- [x] 각 자리 숫자의 곱셈 연산  
```operMulti()```에서는 페이지 자리수 배열을 순회하며 곱셈을 하여 점수를 도출한다. *단, 주의할 점으로 자리수를 다루는 것이므로 0의 취급에 주의해야 한다.*
100에서 일의 자리와 십의 자리의 0은 유효한 숫자로 곱셈을 해야한다. 그러나 10을 배열에 담은 010에서 백의 자리의 0은 유효한 수가 아니다. 이 점을 유의해야한다.  
- [x] 각 자리 숫자의 덧셈 연산  
```operPlus()```에서는 페이지 자리수 배열을 순회하며 덧셈을 하여 점수를 도출한다.  


---  


## 🚀 기능 요구 사항

포비와 크롱이 페이지 번호가 1부터 시작되는 400 페이지의 책을 주웠다. 책을 살펴보니 왼쪽 페이지는 홀수, 오른쪽 페이지는 짝수 번호이고 모든 페이지에는 번호가 적혀있었다. 책이 마음에 든 포비와 크롱은 페이지 번호 게임을 통해 게임에서 이긴 사람이 책을 갖기로 한다. 페이지 번호 게임의 규칙은 아래와 같다.

1. 책을 임의로 펼친다.
2. 왼쪽 페이지 번호의 각 자리 숫자를 모두 더하거나, 모두 곱해 가장 큰 수를 구한다.
3. 오른쪽 페이지 번호의 각 자리 숫자를 모두 더하거나, 모두 곱해 가장 큰 수를 구한다.
4. 2~3 과정에서 가장 큰 수를 본인의 점수로 한다.
5. 점수를 비교해 가장 높은 사람이 게임의 승자가 된다.
6. 시작 면이나 마지막 면이 나오도록 책을 펼치지 않는다.

포비와 크롱이 펼친 페이지가 들어있는 리스트/배열 pobi와 crong이 주어질 때, 포비가 이긴다면 1, 크롱이 이긴다면 2, 무승부는 0, 예외사항은 -1로 return 하도록 solution 메서드를 완성하라.

### 제한사항

- pobi와 crong의 길이는 2이다.
- pobi와 crong에는 [왼쪽 페이지 번호, 오른쪽 페이지 번호]가 순서대로 들어있다.

### 실행 결과 예시

| pobi | crong | result |
| --- | --- | --- |
| [97, 98] | [197, 198] | 0 |
| [131, 132] | [211, 212] | 1 |
| [99, 102] | [211, 212] | -1 |
