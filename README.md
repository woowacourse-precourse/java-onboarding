# 미션 - 온보딩

## 'git’과 '과정별 언어’를 학습하면서 느낀 점

- 우선 이렇게까지 기능별로 세세하게 나눠서 커밋해 본적이 없었기 때문에 굉장히 소중한 경험이 되었다. 처음엔 완성되지 않은 기능을 먼저 커밋해놨다가 나중에 수정할 일이 생기게되면 어떡하지? 하는 생각에 굉장히
  조심스러웠지만, 기능별로 커밋하다보니 기록이 굉장히 깔끔하게 남고, 나중에 에러가 생겼을 때 여러 기능 목록이 합쳐진 커밋이라면 수정하기가 까다롭겠구나 하는 깨달음도 얻었다. 나중에 협업을 하게되면 내 코드를
  나만 보는게 아니라 다른 사람도 보게 될 테니, 기능 별로 커밋 하는 것이 상대방으로 하여금 코드를 더 잘 이해할 수 있게 해주겠구나 하는 생각 또한 들었다.
- 변수명과 함수명을 정하는데에도 꽤 많은 시간을 썼던 것 같다. 기존에 알고리즘 문제를 풀때는 'a'같은 변수명을 자주 사용했다. 하지만 1주차 프리코스 과제를 진행하면서 클린한 코드는 뭘까 고민하며 고민해본 결과
  이러한 변수명을 사용하게 되면, 다른 사람(혹은 미래의 나)이 변수명을 읽었을 때 그 뒤의 추가적인 코드를 읽어야지만 해당 변수명이 어떤 역할인지 이해할 수 있다. 또 해당 변수가 몇 줄 뒤에 또다시 나타날 경우
  어떤 변수였는지 잊어버리게 된다. 그렇기 때문에 과제를 구현하는 과정에서 어떤 단어가 가장 효과적으로 함수를 나타낼지, 함수명이 너무 길어 가독성이 떨어지지는 않는지 많은 검토를 했던 것 같다.
- 문제를 구현하는 과정에서 떠오르는 궁금증은 즉각즉각 해결해가며 진행해 나갔는데, 이 과정에서 기록의 중요성을 느끼게 되었다. 예전에 ConcurrentModificationException을 경험했던 적이
  있었는데, 이번에 문제를 구현하면서 같은 문제를 또 겪었기 때문이다. 따라서 '나만의 해결법' 등을 기록하는 과정에서 되새김질하는 과정이 필요하다고 생각하게 되었다.
- 4번 문제의 경우 처음엔 절차지향적인 코드로 구현했었다. 하지만 4번 문제를 객체지향적으로 바꿔봐야겠다는 생각에 코드를 리팩토링했다. 4번은 현재 대문자, 소문자의 경우에만 규칙이 존재하지만, 이후에
  다른 문자에 대한 요구사항이 추가될 경우 SRP를 위배하겠다 라는 생각이 들었기 때문이다. 이 부분을 팩토리패턴으로 구현해 보면서, 객체지향적으로 코드를 작성하는 방식, SOLID 원칙을 코드에 녹이는 방법을 연습했던 것 같다. 

## ✏️ 기능 목록

1. Problem 1
    - [X] pobi 혹은 crong이 펼친 페이지의 숫자가 (오른쪽페이지 - 왼쪽페이지 = 1) 인지 판별하고, 아니라면 -1을 반환하는 함수
    - [X] 각 자리의 숫자를 더해서 결과값을 리턴하는 함수
    - [X] 각 자리의 숫자를 곱해서 결과값을 리턴하는 함수
    - [X] pobi의 최댓값과 crong의 최댓값을 비교하는 함수


2. Problem 2
    - [X] cryptogram에 중복이 있는 지 확인하는 기능
    - [X] cryptogram에 중복이 있다면 이를 제거하는 기능


3. Problem 3
    - [X] number 내에 3 혹은 6 혹은 9가 존재하는지 확인하는 기능
    - [X] 전체 손뼉 횟수를 계산하는 기능


4. Problem 4
    - [X] 개구리어로 변환하는 기능


5. Problem 5
    - [X] 각 화폐를 내림차순으로 돌면서 나눠질 때까지 나누는 기능
    - [X] result 배열에 화폐의 갯수를 추가하는 기능


6. Problem 6
    - [X] 같은 글자가 연속적으로 포함되는지 판단하는 기능
    - [X] 중복이 있는 닉네임의 이메일을 추출하는 기능


7. Problem 7
    - [X] '친구의 친구'인 경우 10점을 부여하는 기능
    - [X] '방문자'인 경우 1점을 부여하는 기능
    - [X] 결과값을 내림차순으로 정렬하는 기능
    - [X] 최대 5명을 return하는 기능
    - [X] 추천 점수가 같은 경우 이름순으로 정렬하는 기능
