# PROBLEM 1

## 🚀 기능 요구 사항

포비와 크롱이 페이지 번호가 1부터 시작되는 400 페이지의 책을 주웠다. 책을 살펴보니 왼쪽 페이지는 홀수, 오른쪽 페이지는 짝수 번호이고 모든 페이지에는 번호가 적혀있었다. 책이 마음에 든 포비와 크롱은 페이지 번호 게임을 통해 게임에서 이긴 사람이 책을 갖기로 한다. 페이지 번호 게임의 규칙은 아래와 같다.

1. 책을 임의로 펼친다.
2. 왼쪽 페이지 번호의 각 자리 숫자를 모두 더하거나, 모두 곱해 가장 큰 수를 구한다.
3. 오른쪽 페이지 번호의 각 자리 숫자를 모두 더하거나, 모두 곱해 가장 큰 수를 구한다.
4. 2~3 과정에서 가장 큰 수를 본인의 점수로 한다.
5. 점수를 비교해 가장 높은 사람이 게임의 승자가 된다.
6. 시작 면이나 마지막 면이 나오도록 책을 펼치지 않는다.

포비와 크롱이 펼친 페이지가 들어있는 리스트/배열 pobi와 crong이 주어질 때, 포비가 이긴다면 1, 크롱이 이긴다면 2, 무승부는 0, 예외사항은 -1로 return 하도록 solution 메서드를 완성하라.

## 🥕 구현 목록 정리

- 페이지 확인
    - [X] 페이지 번호가 연속이어야 함
    - [X] 왼쪽 페이지는 홀수, 오른쪽 페이지는 짝수
    - [ ] 왼쪽 페이지는 1 이상, 오른쪽 페이지는 400 이하
    - [ ] [1, 2], [399, 400] 페이지는 펼치지 않음
    - `위 두개 제한 사항에 대해서는 생각을 좀 더 해봐야 할듯`
    - [X] 위의 조건에 하나라도 만족하지 않는다면, return -1
- 각 플레이어 점수 구하기
  - [X] 왼쪽, 오른쪽 페이지의 합과 곱의 최대값 구하기
  - [X] 최대합과 최대곱 중 더 큰 값 구하기
- 플레이어 비교
  - [X] pobi의 점수가 더 크다면, return 1
  - [X] crong의 점수가 더 크다면, return 2
  - [X] 같다면, return 0


# PROBLEM 2

## 🚀 기능 요구 사항

암호문을 좋아하는 괴짜 개발자 브라운이 이번에는 중복 문자를 이용한 새로운 암호를 만들었다. 예를 들어 "browoanoommnaon"이라는 암호문은 다음과 같은 순서로 해독할 수 있다.

1. "browoanoommnaon"
2. "browoannaon"
3. "browoaaon"
4. "browoon"
5. "brown"

임의의 문자열 cryptogram이 매개변수로 주어질 때, 연속하는 중복 문자들을 삭제한 결과를 return 하도록 solution 메서드를 완성하라.

## 🥕 구현 목록 정리


- [X] 중복 문자 확인
  - [X] 연속된 모든 중복 문자 체크
- [X] 중복 문자 제거
- [X] 중복 문자가 없을 때 까지, 반복 


# PROBLEM 3

## 🚀 기능 요구 사항

배달이가 좋아하는 369게임을 하고자 한다. 놀이법은 1부터 숫자를 하나씩 대면서, 3, 6, 9가 들어가는 숫자는 숫자를 말하는 대신 3, 6, 9의 개수만큼 손뼉을 쳐야 한다.

숫자 number가 매개변수로 주어질 때, 1부터 number까지 손뼉을 몇 번 쳐야 하는지 횟수를 return 하도록 solution 메서드를 완성하라.

## 🥕 구현 목록 정리
- [X] 1부터 number까지 각 숫자에 3, 6, 9 가 포함된 갯수 체크



# PROBLEM 4

## 🚀 기능 요구 사항

어느 연못에 엄마 말씀을 좀처럼 듣지 않는 청개구리가 살고 있었다. 청개구리는 엄마가 하는 말은 무엇이든 반대로 말하였다.

엄마 말씀 word가 매개변수로 주어질 때, 아래 청개구리 사전을 참고해 반대로 변환하여 return 하도록 solution 메서드를 완성하라.

| A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Z | Y | X | W | V | U | T | S | R | Q | P | O | N | M | L | K | J | I | H | G | F | E | D | C | B | A |

## 🥕 구현 목록 정리

- word의 각 character 별 반대로 변환
  - [X] 알파벳이 아니라면, 그대로 추가
  - 소문자라면, 아스키코드로 `97 ~ 122`
  - 대문자라면, 아스키코드로 `65 ~ 90`
  - [X] 기존 단어는 `a(A)`에서 부터 순서 =  변환될 단어는 `z(Z)`에서 부터의 순서


# PROBLEM 5

## 🚀 기능 요구 사항

계좌에 들어있는 돈 일부를 은행에서 출금하고자 한다. 돈 담을 지갑이 최대한 가볍도록 큰 금액의 화폐 위주로 받는다.

돈의 액수 money가 매개변수로 주어질 때, 오만 원권, 만 원권, 오천 원권, 천 원권, 오백원 동전, 백원 동전, 오십원 동전, 십원 동전, 일원 동전 각 몇 개로 변환되는지 금액이 큰 순서대로 리스트/배열에 담아 return 하도록 solution 메서드를 완성하라.

## 🥕 구현 목록 정리
- [X] 큰 단위순으로 반환 가능 여부 확인
- [X] 가능하다면, 최대한 많이 반환


# PROBLEM 6

## 🚀 기능 요구 사항

우아한테크코스에서는 교육생(이하 크루) 간 소통 시 닉네임을 사용한다. 간혹 비슷한 닉네임을 정하는 경우가 있는데, 이러할 경우 소통할 때 혼란을 불러일으킬 수 있다.

혼란을 막기 위해 크루들의 닉네임 중 **같은 글자가 연속적으로 포함** 될 경우 해당 닉네임 사용을 제한하려 한다. 이를 위해 같은 글자가 연속적으로 포함되는 닉네임을 신청한 크루들에게 알려주는 시스템을 만들려고 한다.


신청받은 닉네임 중 **같은 글자가 연속적으로 포함** 되는 닉네임을 작성한 지원자의 이메일 목록을 return 하도록 solution 메서드를 완성하라.

## 🥕 구현 목록 정리
- 두 글자 이상의 문자가 연속적으로 순서에 맞추어 포함되어 있는 경우 중복으로 간주한다.
  - 최소 단위인 두 글자로 닉네임 끊기
  - [X] 각 닉네임별로 두 글자 씩 끊어 Map 추가하기
    - `key` : 연속된 두 글자로 끊은 단어 
    - `value` : 가지고 있는 최초의 사람의 index
  - [X] 만약, 닉네임이 1글자라면 끊지 않고 넘기기
  - [X] Map에 이미 key 값으로 존재한다면
    - [X] 중복 닉네임으로 list에 추가
    - [X] 기존의 value 값의 이메일도 추가
- [X] answer에서 중복값 지우고, 사전순으로 정렬하여 return


# PROBLEM 7

## 🚀 기능 요구 사항

레벨 2의 팀 프로젝트 미션으로 SNS(Social Networking Service)를 만들고자 하는 팀이 있다. 팀에 속한 크루 중 평소 알고리즘에 관심이 많은 미스터코는 친구 추천 알고리즘을 구현하고자 아래와 같은 규칙을 세웠다.

- 사용자와 함께 아는 친구의 수 = 10점
- 사용자의 타임 라인에 방문한 횟수 = 1점

사용자 아이디 user와 친구 관계 정보 friends, 사용자 타임 라인 방문 기록 visitors가 매개변수로 주어질 때, 미스터코의 친구 추천 규칙에 따라 점수가 가장 높은 순으로 정렬하여 최대 5명을 return 하도록 solution 메서드를 완성하라. 이때 추천 점수가 0점인 경우 추천하지 않으며, 추천 점수가 같은 경우는 이름순으로 정렬한다.

### 🥕 구현 목록 정리
- [X] 친구 관계 그래프 만들기
- [X] user의 친구들의 친구들 + 10점
  - [X] user의 친구들은 점수 X 
  - ✅ `user와 함께 아는 친구의 수 만큼 + 10`
- [X] visitor들에게  + 1점
  - [X] user 친구들은 점수 X
- [X] 점수 별로, 같으면 이름 순으로 정렬
- [X] 최대 5명까지 return