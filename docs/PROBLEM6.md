### 풀이 과정
1. 기능 구현
- 닉네임 들에서 만들어지는 2개의 단어와 그 단어들이 사용된 횟수를 저장하는 메소드 ✅
- 2번 이상 사용 된 단어이며, 닉네임에 해당 단어가 포함되어있다면, 해당 단어에 방문 체크하는 메소드 ✅
- 해당 단어가 중복되는 단어를 포함하는 단어라면 정답에 넣어주는 메소드 ✅

> 수정 :  
제한사항에서 result 의 이메일 문자열의 중복을 제거한다를 발견 후 코드 수정

2. Stream 을 사용하여 정답 list 를 정렬함과 동시에 distinct() 메소드를 사용하여 중복을 제거해 줌 ✅

### 리팩토링 과정
1. solution 클래스 내부에 모든 코드를 작성 후 테스트 케이스를 통해 예외사항을 찾아내 코드를 수정함
2. 리팩토링 수행  
##### 들여쓰기는 한 단계만 허용했는가?  
처음엔 들여쓰기를 한 단계만 허용하기 위해 메소드 내에서 다른 메소드를 계속 호출하면서 코드를 리팩토링했다. 
그러나 코드를 타고 들어가면 들어 갈 수록 메소드의 인자수는 늘어났고, 이 메소드가 과연 어떤 기능을 하는 메소드인지 알 수 없게 되었다.

의도적으로 들여쓰기를 한 단계만 허용하기 위해 강박적으로 메소드를 구성할 필요는 없다고 생각했다. 코드가 명확한 기능을
할 수 있을만큼만 분리하면 된다고 판단하였다.

그래서 기본적인 리팩토링은 하나의 메소드가 하나의 기능을 담당하도록 코드를 작성하되, 들여쓰기가 한 번 더 사용되더라도
그 메소드가 하는 기능을 명확하게 알수 있게 리팩토링 하였다.
#### 메소드의 인자 수를 제한했는가? (4개 이상 인자 허용 x, 3개도 가능하면 줄이기)  
처음에 모든 자료구조와 배열 등을 static 으로 선언하여 호출하도록 코드를 작성하였다. 그러나 테스트를 위해 테스트를 진행하면
각각의 테스트 케이스 하나를 실행했을 때는 테스트가 성공하였지만, 전체 테스트 케이스를 실행했을 때는 테스트에 실패하는 문제가 발생하였다.

이는 각 테스트 케이스마다 solution 함수가 호출 될 때 자료구조가 새로 선언되지 않고 static 으로 하나의 자료구조가
계속 호출되었기 때문이라는 것을 알게되었고, static 으로 선언했던 것들을 모두 solution 클래스로 옮기고
메소드의 인자로 옮기기 시작하였다.

그러나 이 또한 문제가 있었는데, 메소드의 인자가 너무 많이 늘어나기 시작한것이다. 그래서 사용되는 자료구조나 배열등의 인스턴스들을 
static 으로 선언하되, solution 이 실행될 때 인스턴스를 생성하였다. 이와 같이 리팩토링을 진행하자 메소드의 인자의 개수가
확연하게 줄었다.
#### 코드 한줄에 점(.)을 하나만 허용했는가 ?
문제 중 자료구조 안에 자료구조가 들어있는 상태로 주어졌을 때, 그 중 원하는 값을 뽑아오기 위해 점을 여러개 사용할 수 밖에 없는 경우가 있었다.
이는 향상된 for 문을 사용하여 점의 갯수를 줄일 수 있었으나, 점이 알아 보기 힘들 정도로 여러개의 점이 아닌 이상
그렇게 강박적으로 코드 한줄에 점을 허용할 필요는 없다고 생각했다. 오히려 그렇게 하여 변수가 추가되어 더 알아보기 힘들게
코드가 작성되기도 했기 때문이다.

stream() 등의 경우에는 변수로서 알아보기 위한 것이 아니라고 생각하였기 때문에 상관없다고 생각했다.
#### 메소드의 기능과 메소드 명이 일맥상통하는가 ?
쉬워보이지만 가장 어렵기도 한 부분이었다.