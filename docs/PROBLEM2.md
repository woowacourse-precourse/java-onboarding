## 🚀 기능 요구 사항

암호문을 좋아하는 괴짜 개발자 브라운이 이번에는 중복 문자를 이용한 새로운 암호를 만들었다. 예를 들어 "browoanoommnaon"이라는 암호문은 다음과 같은 순서로 해독할 수 있다.

1. "browoanoommnaon"
2. "browoannaon"
3. "browoaaon"
4. "browoon"
5. "brown"

임의의 문자열 cryptogram이 매개변수로 주어질 때, 연속하는 중복 문자들을 삭제한 결과를 return 하도록 solution 메서드를 완성하라.

### 제한사항

- cryptogram은 길이가 1 이상 1000 이하인 문자열이다.
- cryptogram은 알파벳 소문자로만 이루어져 있다.

### 실행 결과 예시

| cryptogram | result |
| --- | --- |
| "browoanoommnaon" | "brown" |
| "zyelleyz" | "" |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
풀이 과정
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
```
처음부터 다시 풀었습니다
```
### 틀린 풀이 과정
만약 aaabbba라는 문자가 들어왔을 경우 a를 먼저 제거해서 a가 남거나, b를 먼저 제거해서 전부 제거 하는 두 가지 경우가 있다고 생각했습니다. 문제에서 
암호의 길이를 최대한 줄인다는 말이 없었기에 전자의 방법으로 생각하고 풀었습니다. 

암호를 배열로 만들고 배열을 돌면서 i와 i + 1이 같은지 체크 했습니다. 같은 경우 remove_메서드를 이용합니다. remove_메서드는 암호의 첫 번째 인덱스부터
중복 되는 문자전까지 자르고, 중복 되는 문자의 갯수만큼 인덱스를 뛰어서 그 뒤부터 남은 문자를 더해서 반환을 해줍니다. 중복 되는 단어가 없다면 멈추고
남은 문자를 반환합니다. solution은 사용자에게 암호를 해석하라고 건네 주는 과정이라고 생각했고, 그래서 decoder는 암호를 해독하는 해독기와 암호를 재정립하는 
remove_, overLap은 중복 되었는지 확인해주는 메서드로 각각 생각했기에 각 메서드를 분리해주었습니다.

### 다시 제출한 풀이 과정
처음부터 다시 풀었습니다. 처음에는 연속된 두 문자만 지워지게해서 aabbbcdff같은 경우는 처리하지 못했습니다. 암호를 리스트로 만들어 can_remove_overlap메서드를 통해 리스트를 돌며 중복문자가 나오면 계속 제거, 나오지 않으면 true를 반환하게했습니다. 제거가 끝나면 true를 통해 while문을 빠져나와 다시 문자열로 만들어 반환해주었습니다.



