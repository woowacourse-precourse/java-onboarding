### problem 1 

2022.10.26. 1800
리스트의 요소를 구하는 메소드로 컬렉션프레임워크로 주어지고 있기 때문에 size()를 사용해서 바로 알 수 있다. 

2022.10.26. 1900
리팩토링 해야 할 부분 : 제한사항으로 리턴 -1을 하도록 하는 if 절 기능을 어떻게 메소드로 뺄지 고민 

2022.10.26. 2200
작동은 되도록 하는 로직 완성
1. 최대값을 구할 때 리스트를 쓰지 않고 구할 수 없을까
2. 자리수를 나누고 각 숫자마다 반복문을 돌려서 덧셈과 곱셉의 최대값을 구하고
3. 그걸 또 리턴해와서 list를 만들어서 최대값을 구하는 것
뭔가 이래서는 안되는걸 알면서도 달리 방법을 모르겠다. 

어떻게 공부를 해야 이 코드를 뜯어고칠수 있을까 . . .


### problem 2 

2022.10.27 1500
문자열을 하나 하나씩 비교하는 반복문을 생각할 수도 있겠지만
어떻게든 regex를 이용해서 풀어보고 싶었다. 

regex 관련 공부를 했다. 

자바에서는 개행문자 때문에 \를 한 번 더 써주어야 하고 
\w는 모든 word를 의미, \1+은 중복되는 것을 찾는다. 
+는 1회 이상 반복되는 값을 나타낸다. 
괄호를 통해 문자 단위를 만든다. 

패턴 Matcher의 find()를 통해 regex에 일치하는 상황이 발생했을 때 true를 리턴 받는다.
matcher에 다양한 함수가 있었지만 한번에 문제를 해결할 수 있는 것으로 
여러가지를 시도했지만 딱 원하는 위치의 원하는 문자를 리턴해주는 메소드를 
찾지 못해서 반복문을 사용해서 돌리면서 
이때 stringbuffer를 이용해 찾은 위치의 문자를 ""으로 대체함으로써 삭제하는 방법을 찾았다.

1회로 돌렸을 때 원하는 값인 browoannaon가 나왔고 
반복문으로 find()에서 false가 리턴될 때까지 찾으면 정답을 구할 수 있게 되었다. 

2022.10.27 2000 
기능별 메소드를 분리하고자 했으나 변수 초기화와 while문 구성에서 다른 방법을 찾지 못해
추후 리팩토링 과제로 남겨두기로 하고 커밋 


### problem 3 

2022.10.27 2100
number가 10 미만일 경우와 그 이상일 경우를 나눠보기... 

2022.10.27 2130
스트링으로 바꾸고 스트링에서 3, 6, 9 값을 찾는 방식으로 했을 경우
중복을 제외하고 쉽게 포착이 가능해진다. 

하지만 중복은. . . 

for문을 돌려서 모든 숫자에 대해서 검증을 하면 너무 많은 자원을 먹게 된다. 

중복만 검증할 것이 아니라 
33, 36, 39 같이 나오는 숫자를 검증해야 한다. 
결국엔 정규식을 이용하는 수 밖에 없는듯 하다. 

33, 36, 39 
63, 66, 69 
93, 96, 99 
133, 166, 169
...
333, 336, 339 
...
3333, 3336, 3339

정규식을 통해 반복 숫자가 나올 때 
카운트를 늘려주는 방식으로 해결 

if문이 너무 nested 된다는 점이 문제 

2022.10.27 2300
치명적인 문제를 발견했다. 
구문이 겹치는 것 외에도 숫자가 3자리수 이상으로 올라갈 때 333 같은 경우 
카운트를 3번해야 하는데 현재 로직에서는 2번 밖에 하지 못한다. 
결국엔...
접근을 바꾸던가 
새로운 카운트 방법을 써야한다. 


2022.10.27 2350
간단한 방법을 찾았다 => 스트링에서 발견되는 개수를 카운팅으로 바로 포함시켜서 
1개 발견시 +1 2개 발견시 +2 식으로 sum을 구해주면 된다. 


### problem 4 


2022.10.28 0010
자바에서는 아스키 코드를 형변환과 함께 사용할시 유니코드에 해당하는
알파벳을 출력할 수 있는 기능이 있는 것을 확인 
ex) 
System.out.println((char) 65); => A
System.out.println((char) 90); => Z

이말인즉슨, 65~ 90까지의 숫자를 잘 조작하면
정배열과 역배열의 규칙을 발견할 수 있다는 뜻 

규칙을 구하고 + 대소문자 구별로 맞춰준다면
문제를 쉽게 풀 수 있을듯 하다. 

65 = 90 => 155 
... 
73 = 82 => 155

대문자의 경우 155 - a를 해주었을 때 
reverse를 구할 수 있다. 


소문자의 경우 97 ~ 122 
=> 219

대소문자 구분과 스페이스 처리하는 부분을 
업데이트 

반복문을 통해 쉽게 출력 성공!

2022.10.28 0040
그런데... 
이번 문제는 생각보다 쉽게 풀려서 그런지
찜찜함이 가시질 않긴한다. 



### problem 5

2022.10.28 0830
5만원 권 ~ 1원까지 단순 반복문을 돌려서 
하나씩 추출하는 방법을 쓰면 너무 많은 중첩문들이 생길 것이 뻔하다. 

원 단위를 배열로 만들고 그것을 꺼내면서 
반복문을 돌리며 카운트를 계산하는 방식을 사용 

이때 카운트를 구하는 것은 구현이 가능한데 문제는 
리스트에 집어넣는 때였다. 

문제의 처음에 제시된 리스트 형식이 Collections.emptylist() 이기 때문에
이것을 그대로 사용하는 방법을 고민했다. 

검색 결과 Collections.emptylist() 방식과 new ArrayList() 방식의 차이를 다루는 글들이 보였다. 

핵심 차이는 불변성에 있다고 한다. 
emptylist() 방식은 수정되지 않는 배열을 리턴한다. 
따라서 add 하는 방식으로 사용이 불가능하다는 점이다. 

이 방식은 list 타입을 반환하지 않고 list<T>를 반환하기 때문에 타입 안전성을 보장한다는 
장점이 있어서 사용된다고 한다. 

이것이
계속해서 UnsupportedOperationException이 발생한 이유이고
지금의 내가 쓰는 코드는 따라서 이 방식이 완전히 문제가 되는 
상황이다. 

그렇다면...
고민이 드는 것이다. 

대체 왜 이런 방식이 기본 셋업으로 주어졌을까? 

2022.10.28 0940

스택오버플로우를 비롯해 여러 커뮤니티의 글들을 
읽고 내린 결론은 
결국 emptylist()는 절대적으로 빈 리스트만을 리턴해야 할 때만 
사용할 수 있다는 것이며 
그렇다면 대체 왜 이걸 사용하는가를 고민하면서
얻은 답변은 
이것의 사용 이유는 empty 리스트를 반환해야 하는 상황에서
cpu 등의 자원 효율성을 위해서 사용한다는 것이었다. 

따라서 결론적으로 이번 문제에서는 이 방식을 유지하면서는
절대 원하는 값을 리턴할 수 없다는 결론이 나왔다. 


### problem 6

2022.10.28 1300

2차원 배열 
이 문제를 보고 처음 떠올린 생각은 카테시안 곱이었다. 

2022.10.28 1430
숫자 값이 아니기 때문에 카테시안 곱을 이용하기는 애매하다는 결론. 

반복문 내에서 
forms.get(i)으로 1차원 배열에 접근할 수 있다.
그렇다면 각각의 배열을 하나씩 비교하는 방식의 풀이를 고려해본다. 

0 -> 비교 1,2,3,4,5 
1 -> 비교 0,2,3,4,5  

이때 1차원 배열에 해당하는 리스트를 제외한 나머지 2차원 리스트를 반복문을 돌리는 방식을
사용해보려 했으나 remove()가 되지 않기 때문에 다른 방식을 고려 


2022.10.28 1500 
2차원 배열에서 요소인 1차원 리스트에 접근하여
개별적으로 비교하는 로직을 구성하는 것까지 성공 

이제 각각의 리스트에서 name을 뽑아낼 수 있기 때문에
name간 비교가 가능해졌다.

여기서 name을 어떤 방식으로 비교할지를 고민 
문제는...
한글자만 같아서는 안되며 같은 글자가 연속적으로 포함되는 경우의
중복을 포착해야 한다는 것이다. 


2022.10.28 1600
중복을 포착하여 불리언을 리턴하는 함수 구성 

이제 중복이 포함된 이름을 포착할 수 있게 되었고
email과 매칭시켜 리스트에 넣어 리턴하는 것으로 답을 
찾을 수 있게 되었다. 



### problem 7

2022.10.28 1630 

먼저 2차원 친구 리스트를 푼다. 
1차원 리스트인 각 요소에서 [x, y]가 주어지면 
x가 살펴야 하는 것은 y와 user의 관계와 본인과 user와의 관계이다. 
즉, [donut, andole]를 예로 들면, 
첫 번째로 donut 스스로가 user와 친구인지를 살펴보기 위해
다른 리스트들을 살펴본다.
두 번째로 donut은 andole가 user와 친구인지를
살펴보기 위해 다른 리스트들을 살펴본다.


기준 친구 리스트와 다른 친구 리스트를 비교하는 반복문 구현 

이 다음은 

1. 기준이 된 친구가 user와 친구인지를 살펴보기 위해
   기준 이름이 다른 리스트를 돌면서
   1) 기준 이름이 그 안에 들어 있는지
   2) 들어 있다면 그게 user와 짝을 맺고 있는지 

=> 만약에 맺고 있다면 더 이상 볼 필요 없이 pass 

그렇지 않다면 2번 조건 
2. 다른 리스트를 돌면서 
1) 나와 짝을 맺고 있는 이름이 다른 리스트에 등장하는지
2) 등장한다면 user와 짝을 맺고 있는지 
=> 짝이라면 나에게 10점 ! 

2022.10.28 1900

기존 로직에서 반복문 로직으로 구해지지 않는 문제에 직면해서 
이름을 먼저 구하고 이것을 2개로 나누어 반복문을 도는 형태로 수정 


2022.10.28 2000

점수를 sum하는 부분에서 맵을 사용해 key value를 구분해주었고
merge 메소드를 사용해 더해지는 방식을 구현 


visitor에서 friends 관계에서 파악한 중복되는 친구들을 제거해주기 위해
별도 관리 리스트를 생성하여 관리 

visitor 부분 구현은 
반복문을 통한 개별 string name 파악, 
이때 중복 name은 패스 
중복되지 않은 name에 대해서 기존의 리스트에 추가하여 +1 



출력 조건에 대해 살펴본다.

1) 높은순으로 정렬할 것
2) 5명 미만일 것
3) 추천 점수가 0점인 경우 제외할 것 
4) 추천 점수가 같으면 이름순으로 정렬할 것 


2022.10.28 1800
3번의 0점인 경우 remove를 할 때 LinkedHashMap에서는 
반복하면서 삭제가 안되는 오류가 발생 

이를 hasNext()로 반복문을 돌리는 방식으로 하면 가능한데
한줄로 정리된 람다 표현식이 있어서 이것으로 해결했다. 

마지막으로 리스트로 변환하고 value 부분을 regex로 지워주면서
리턴해주어 답을 도출 

2022.10.29 0900 

클린코드 원칙 #1 자바 컨벤션 공부 및 적용 

2022.10.29 1300

클린코드 원칙 #2 한 메서드에 오직 한 단계 들여쓰기만 원칙 공부 및 리팩토링 추진

2022.10.29 1300 - 1800 
전체 코드 리팩토링 

2022.10.30 0900 - 
클린코드 원칙 #3-4를 적용하며 코드 리팩토링 
problem1의 복잡한 코드를 메서드로 많이 분기했다. 

2022.10.31 0800 - 
problem2를 분기했다.
field로 regex를 올렸는데 while문에서 메서드가 돌아가면서 계속 호출이 되기 때문에
field에서 정의해주는 것이 맞는 것 같다. 

클린코드 원칙 #6 3개 이상의 변수를 가진 클래스를 구현하지 않았는가? 
에 도달하면서 의문이 생기게 되었다.
메서드를 분기하는 것만으로 충분하지 않고 새로운 클래스를 만들어
포괄적인 개념 설정을 해주어야 할 것 같은데 그러자면 Prolblem 별로 
별도의 패키지를 만들어 거기서 클래스를 관리해주거나 
패지키를 만들지 않을 것이라면 problem1XXX 식으로 이름을 구분하여
관리가 필요할 것이기 때문이다. 

하지만 onboarding 폴더에 problem이 1~7까지 주어진 상황에서
그런식의 분기가 문제의 의도와 맞는가란 의문이 들었다. 

문제의 요구사항으로 제시된 "프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 이름을 수정하거나 이동하지 않는다."에
따라 새로운 패키지를 만들거나 폴더의 상황을 바꾸는 것이 꺼려졌다.


2022.10.31 1600
매직넘버를 상수로 바꿔주는 리팩토링 진행 

